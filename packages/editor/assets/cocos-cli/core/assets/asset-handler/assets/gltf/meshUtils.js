"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeMeshes = mergeMeshes;
const cc_1 = require("cc");
function mergeMeshes(meshes = []) {
    if (meshes.length === 0) {
        // create a empty mesh
        console.warn('mergeMeshes: meshes is empty');
        return new cc_1.Mesh();
    }
    if (meshes.length === 1) {
        return meshes[0];
    }
    if (meshes.every((mesh) => mesh.struct.compressed)) {
        return new cc_1.Mesh();
    }
    const validate_morph = (meshes) => {
        const morphs = meshes.map((mesh) => mesh.struct.morph);
        if (morphs.every((morph) => morph === undefined)) {
            // if all undefined, exit immediately
            return true;
        }
        return false;
    };
    const validate_compress = (meshes) => {
        const encodeds = meshes.map((mesh) => mesh.struct.encoded);
        const compresses = meshes.map((mesh) => mesh.struct.compressed);
        const quantizeds = meshes.map((mesh) => mesh.struct.quantized);
        if (encodeds.every((encoded) => encoded === undefined) &&
            compresses.every((compress) => compress === undefined) &&
            quantizeds.every((quantized) => quantized === undefined)) {
            // if all undefined, exit immediately
            return true;
        }
        const firstEncoded = encodeds[0];
        for (let i = 1; i < encodeds.length; i++) {
            if (encodeds[i] !== firstEncoded) {
                return false;
            }
        }
        const firstCompress = compresses[0];
        for (let i = 1; i < compresses.length; i++) {
            if (compresses[i] !== firstCompress) {
                return false;
            }
        }
        const firstQuantized = quantizeds[0];
        for (let i = 1; i < quantizeds.length; i++) {
            if (quantizeds[i] !== firstQuantized) {
                return false;
            }
        }
        return true;
    };
    // validate joint map[][], joint map should be the same
    const validata_jointMap = (meshes) => {
        const jointMaps = meshes.map((mesh) => mesh.struct.jointMaps);
        // no joint map, or all joint map are the same
        if (jointMaps.every((jointMap) => jointMap === undefined)) {
            return true;
        }
        // all should be the same, data
        const firstJointMap = jointMaps[0];
        const xdim = firstJointMap.length;
        for (let i = 1; i < jointMaps.length; i++) {
            const jointMap = jointMaps[i];
            if (jointMap.length !== xdim) {
                return false;
            }
            for (let j = 0; j < jointMap.length; j++) {
                const ydim = firstJointMap[j].length;
                if (jointMap[j].length !== ydim) {
                    return false;
                }
                for (let k = 0; k < ydim; k++) {
                    if (jointMap[j][k] !== firstJointMap[j][k]) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    if (!validate_compress(meshes)) {
        console.warn('mergeMeshes: encoded state is not the same');
        return new cc_1.Mesh();
    }
    if (!validata_jointMap(meshes)) {
        console.warn('mergeMeshes: jointMap is not the same');
        return new cc_1.Mesh();
    }
    if (!validate_morph(meshes)) {
        console.warn('mergeMeshes: morph is not supported');
        return new cc_1.Mesh();
    }
    const bufferSize = meshes.reduce((acc, cur) => {
        return acc + cur.data.byteLength;
    }, 0);
    const data = new Uint8Array(bufferSize);
    const vertexBundles = [];
    const primitives = [];
    let data_offset = 0;
    let bundle_offset = 0;
    const minPosition = meshes[0].struct.minPosition || new cc_1.Vec3(1e9);
    const maxPosition = meshes[0].struct.maxPosition || new cc_1.Vec3(-1e9);
    for (let i = 0; i < meshes.length; i++) {
        // copy data from mesh.data to data at offset
        const mesh = meshes[i];
        const meshData = mesh.data;
        // append data to the end of the buffer
        data.set(meshData, data_offset);
        // copy the vertex bundles
        vertexBundles.push(...mesh.struct.vertexBundles.map((bundle) => {
            const newBundle = bundle;
            newBundle.view.offset += data_offset;
            return newBundle;
        }));
        // copy the primitives, and apply the offset to view
        primitives.push(...mesh.struct.primitives.map((primitive) => {
            const newPrimitive = primitive;
            newPrimitive.vertexBundelIndices = primitive.vertexBundelIndices.map((index) => index + bundle_offset);
            if (newPrimitive.indexView) {
                newPrimitive.indexView.offset += data_offset;
            }
            return newPrimitive;
        }));
        data_offset += meshData.byteLength;
        bundle_offset += mesh.struct.vertexBundles.length;
        minPosition.x = Math.min(minPosition.x, mesh.struct.minPosition?.x || 1e9);
        minPosition.y = Math.min(minPosition.y, mesh.struct.minPosition?.y || 1e9);
        minPosition.z = Math.min(minPosition.z, mesh.struct.minPosition?.z || 1e9);
        maxPosition.x = Math.max(maxPosition.x, mesh.struct.maxPosition?.x || -1e9);
        maxPosition.y = Math.max(maxPosition.y, mesh.struct.maxPosition?.y || -1e9);
        maxPosition.z = Math.max(maxPosition.z, mesh.struct.maxPosition?.z || -1e9);
    }
    // TODO: morph and skinning, joints, dynamic, etc.
    const meshCreateInfo = {
        struct: {
            vertexBundles,
            primitives,
            minPosition,
            maxPosition,
            jointMaps: meshes[0].struct.jointMaps,
            dynamic: meshes[0].struct.dynamic,
            compressed: meshes[0].struct.compressed,
            quantized: meshes[0].struct.quantized,
            encoded: meshes[0].struct.encoded,
        },
        data: data,
    };
    const out = new cc_1.Mesh();
    out.reset(meshCreateInfo);
    out.hash;
    return out;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVzaFV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2NvcmUvYXNzZXRzL2Fzc2V0LWhhbmRsZXIvYXNzZXRzL2dsdGYvbWVzaFV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsa0NBMkxDO0FBN0xELDJCQUFtRDtBQUVuRCxTQUFnQixXQUFXLENBQUMsU0FBaUIsRUFBRTtJQUMzQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDdEIsc0JBQXNCO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsOEJBQThCLENBQUMsQ0FBQztRQUM3QyxPQUFPLElBQUksU0FBSSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUN0QixPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7UUFDakQsT0FBTyxJQUFJLFNBQUksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRCxNQUFNLGNBQWMsR0FBRyxDQUFDLE1BQWMsRUFBVyxFQUFFO1FBQy9DLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdkQsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUMvQyxxQ0FBcUM7WUFDckMsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQztRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUMsQ0FB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LENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPO1NBQ3BDO1FBQ0QsSUFBSSxFQUFFLElBQUk7S0FDYixDQUFDO0lBRUYsTUFBTSxHQUFHLEdBQUcsSUFBSSxTQUFJLEVBQUUsQ0FBQztJQUN2QixHQUFHLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzFCLEdBQUcsQ0FBQyxJQUFJLENBQUM7SUFDVCxPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZngsIE1lc2gsIE1vcnBoLCB1dGlscywgVmVjMyB9IGZyb20gJ2NjJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU1lc2hlcyhtZXNoZXM6IE1lc2hbXSA9IFtdKTogTWVzaCB7XHJcbiAgICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIGVtcHR5IG1lc2hcclxuICAgICAgICBjb25zb2xlLndhcm4oJ21lcmdlTWVzaGVzOiBtZXNoZXMgaXMgZW1wdHknKTtcclxuICAgICAgICByZXR1cm4gbmV3IE1lc2goKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBtZXNoZXNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1lc2hlcy5ldmVyeSgobWVzaCkgPT4gbWVzaC5zdHJ1Y3QuY29tcHJlc3NlZCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lc2goKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2YWxpZGF0ZV9tb3JwaCA9IChtZXNoZXM6IE1lc2hbXSk6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIGNvbnN0IG1vcnBocyA9IG1lc2hlcy5tYXAoKG1lc2gpID0+IG1lc2guc3RydWN0Lm1vcnBoKTtcclxuICAgICAgICBpZiAobW9ycGhzLmV2ZXJ5KChtb3JwaCkgPT4gbW9ycGggPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgLy8gaWYgYWxsIHVuZGVmaW5lZCwgZXhpdCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdmFsaWRhdGVfY29tcHJlc3MgPSAobWVzaGVzOiBNZXNoW10pOiBib29sZWFuID0+IHtcclxuICAgICAgICBjb25zdCBlbmNvZGVkcyA9IG1lc2hlcy5tYXAoKG1lc2gpID0+IG1lc2guc3RydWN0LmVuY29kZWQpO1xyXG4gICAgICAgIGNvbnN0IGNvbXByZXNzZXMgPSBtZXNoZXMubWFwKChtZXNoKSA9PiBtZXNoLnN0cnVjdC5jb21wcmVzc2VkKTtcclxuICAgICAgICBjb25zdCBxdWFudGl6ZWRzID0gbWVzaGVzLm1hcCgobWVzaCkgPT4gbWVzaC5zdHJ1Y3QucXVhbnRpemVkKTtcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBlbmNvZGVkcy5ldmVyeSgoZW5jb2RlZCkgPT4gZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSAmJlxyXG4gICAgICAgICAgICBjb21wcmVzc2VzLmV2ZXJ5KChjb21wcmVzcykgPT4gY29tcHJlc3MgPT09IHVuZGVmaW5lZCkgJiZcclxuICAgICAgICAgICAgcXVhbnRpemVkcy5ldmVyeSgocXVhbnRpemVkKSA9PiBxdWFudGl6ZWQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gaWYgYWxsIHVuZGVmaW5lZCwgZXhpdCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZpcnN0RW5jb2RlZCA9IGVuY29kZWRzWzBdITtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGVuY29kZWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmNvZGVkc1tpXSAhPT0gZmlyc3RFbmNvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZpcnN0Q29tcHJlc3MgPSBjb21wcmVzc2VzWzBdITtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbXByZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNvbXByZXNzZXNbaV0gIT09IGZpcnN0Q29tcHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZmlyc3RRdWFudGl6ZWQgPSBxdWFudGl6ZWRzWzBdITtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHF1YW50aXplZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHF1YW50aXplZHNbaV0gIT09IGZpcnN0UXVhbnRpemVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB2YWxpZGF0ZSBqb2ludCBtYXBbXVtdLCBqb2ludCBtYXAgc2hvdWxkIGJlIHRoZSBzYW1lXHJcbiAgICBjb25zdCB2YWxpZGF0YV9qb2ludE1hcCA9IChtZXNoZXM6IE1lc2hbXSk6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIGNvbnN0IGpvaW50TWFwcyA9IG1lc2hlcy5tYXAoKG1lc2gpID0+IG1lc2guc3RydWN0LmpvaW50TWFwcyk7XHJcbiAgICAgICAgLy8gbm8gam9pbnQgbWFwLCBvciBhbGwgam9pbnQgbWFwIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgIGlmIChqb2ludE1hcHMuZXZlcnkoKGpvaW50TWFwKSA9PiBqb2ludE1hcCA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFsbCBzaG91bGQgYmUgdGhlIHNhbWUsIGRhdGFcclxuICAgICAgICBjb25zdCBmaXJzdEpvaW50TWFwID0gam9pbnRNYXBzWzBdITtcclxuICAgICAgICBjb25zdCB4ZGltID0gZmlyc3RKb2ludE1hcC5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBqb2ludE1hcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgam9pbnRNYXAgPSBqb2ludE1hcHNbaV0hO1xyXG4gICAgICAgICAgICBpZiAoam9pbnRNYXAubGVuZ3RoICE9PSB4ZGltKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgam9pbnRNYXAubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHlkaW0gPSBmaXJzdEpvaW50TWFwW2pdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChqb2ludE1hcFtqXS5sZW5ndGggIT09IHlkaW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB5ZGltOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbnRNYXBbal1ba10gIT09IGZpcnN0Sm9pbnRNYXBbal1ba10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghdmFsaWRhdGVfY29tcHJlc3MobWVzaGVzKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignbWVyZ2VNZXNoZXM6IGVuY29kZWQgc3RhdGUgaXMgbm90IHRoZSBzYW1lJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF2YWxpZGF0YV9qb2ludE1hcChtZXNoZXMpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdtZXJnZU1lc2hlczogam9pbnRNYXAgaXMgbm90IHRoZSBzYW1lJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZV9tb3JwaChtZXNoZXMpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdtZXJnZU1lc2hlczogbW9ycGggaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBtZXNoZXMucmVkdWNlKChhY2MsIGN1cikgPT4ge1xyXG4gICAgICAgIHJldHVybiBhY2MgKyBjdXIuZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgfSwgMCk7XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xyXG4gICAgY29uc3QgdmVydGV4QnVuZGxlcyA9IFtdO1xyXG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IFtdO1xyXG5cclxuICAgIGxldCBkYXRhX29mZnNldCA9IDA7XHJcbiAgICBsZXQgYnVuZGxlX29mZnNldCA9IDA7XHJcblxyXG4gICAgY29uc3QgbWluUG9zaXRpb24gPSBtZXNoZXNbMF0uc3RydWN0Lm1pblBvc2l0aW9uIHx8IG5ldyBWZWMzKDFlOSk7XHJcbiAgICBjb25zdCBtYXhQb3NpdGlvbiA9IG1lc2hlc1swXS5zdHJ1Y3QubWF4UG9zaXRpb24gfHwgbmV3IFZlYzMoLTFlOSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBjb3B5IGRhdGEgZnJvbSBtZXNoLmRhdGEgdG8gZGF0YSBhdCBvZmZzZXRcclxuICAgICAgICBjb25zdCBtZXNoID0gbWVzaGVzW2ldO1xyXG4gICAgICAgIGNvbnN0IG1lc2hEYXRhID0gbWVzaC5kYXRhO1xyXG5cclxuICAgICAgICAvLyBhcHBlbmQgZGF0YSB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXJcclxuICAgICAgICBkYXRhLnNldChtZXNoRGF0YSwgZGF0YV9vZmZzZXQpO1xyXG5cclxuICAgICAgICAvLyBjb3B5IHRoZSB2ZXJ0ZXggYnVuZGxlc1xyXG4gICAgICAgIHZlcnRleEJ1bmRsZXMucHVzaChcclxuICAgICAgICAgICAgLi4ubWVzaC5zdHJ1Y3QudmVydGV4QnVuZGxlcy5tYXAoKGJ1bmRsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QnVuZGxlID0gYnVuZGxlO1xyXG4gICAgICAgICAgICAgICAgbmV3QnVuZGxlLnZpZXcub2Zmc2V0ICs9IGRhdGFfb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0J1bmRsZTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gY29weSB0aGUgcHJpbWl0aXZlcywgYW5kIGFwcGx5IHRoZSBvZmZzZXQgdG8gdmlld1xyXG4gICAgICAgIHByaW1pdGl2ZXMucHVzaChcclxuICAgICAgICAgICAgLi4ubWVzaC5zdHJ1Y3QucHJpbWl0aXZlcy5tYXAoKHByaW1pdGl2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJpbWl0aXZlID0gcHJpbWl0aXZlO1xyXG4gICAgICAgICAgICAgICAgbmV3UHJpbWl0aXZlLnZlcnRleEJ1bmRlbEluZGljZXMgPSBwcmltaXRpdmUudmVydGV4QnVuZGVsSW5kaWNlcy5tYXAoKGluZGV4KSA9PiBpbmRleCArIGJ1bmRsZV9vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1ByaW1pdGl2ZS5pbmRleFZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcmltaXRpdmUuaW5kZXhWaWV3Lm9mZnNldCArPSBkYXRhX29mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcmltaXRpdmU7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGRhdGFfb2Zmc2V0ICs9IG1lc2hEYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgYnVuZGxlX29mZnNldCArPSBtZXNoLnN0cnVjdC52ZXJ0ZXhCdW5kbGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgbWluUG9zaXRpb24ueCA9IE1hdGgubWluKG1pblBvc2l0aW9uLngsIG1lc2guc3RydWN0Lm1pblBvc2l0aW9uPy54IHx8IDFlOSk7XHJcbiAgICAgICAgbWluUG9zaXRpb24ueSA9IE1hdGgubWluKG1pblBvc2l0aW9uLnksIG1lc2guc3RydWN0Lm1pblBvc2l0aW9uPy55IHx8IDFlOSk7XHJcbiAgICAgICAgbWluUG9zaXRpb24ueiA9IE1hdGgubWluKG1pblBvc2l0aW9uLnosIG1lc2guc3RydWN0Lm1pblBvc2l0aW9uPy56IHx8IDFlOSk7XHJcblxyXG4gICAgICAgIG1heFBvc2l0aW9uLnggPSBNYXRoLm1heChtYXhQb3NpdGlvbi54LCBtZXNoLnN0cnVjdC5tYXhQb3NpdGlvbj8ueCB8fCAtMWU5KTtcclxuICAgICAgICBtYXhQb3NpdGlvbi55ID0gTWF0aC5tYXgobWF4UG9zaXRpb24ueSwgbWVzaC5zdHJ1Y3QubWF4UG9zaXRpb24/LnkgfHwgLTFlOSk7XHJcbiAgICAgICAgbWF4UG9zaXRpb24ueiA9IE1hdGgubWF4KG1heFBvc2l0aW9uLnosIG1lc2guc3RydWN0Lm1heFBvc2l0aW9uPy56IHx8IC0xZTkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IG1vcnBoIGFuZCBza2lubmluZywgam9pbnRzLCBkeW5hbWljLCBldGMuXHJcbiAgICBjb25zdCBtZXNoQ3JlYXRlSW5mbzogTWVzaC5JQ3JlYXRlSW5mbyA9IHtcclxuICAgICAgICBzdHJ1Y3Q6IHtcclxuICAgICAgICAgICAgdmVydGV4QnVuZGxlcyxcclxuICAgICAgICAgICAgcHJpbWl0aXZlcyxcclxuICAgICAgICAgICAgbWluUG9zaXRpb24sXHJcbiAgICAgICAgICAgIG1heFBvc2l0aW9uLFxyXG4gICAgICAgICAgICBqb2ludE1hcHM6IG1lc2hlc1swXS5zdHJ1Y3Quam9pbnRNYXBzLFxyXG4gICAgICAgICAgICBkeW5hbWljOiBtZXNoZXNbMF0uc3RydWN0LmR5bmFtaWMsXHJcbiAgICAgICAgICAgIGNvbXByZXNzZWQ6IG1lc2hlc1swXS5zdHJ1Y3QuY29tcHJlc3NlZCxcclxuICAgICAgICAgICAgcXVhbnRpemVkOiBtZXNoZXNbMF0uc3RydWN0LnF1YW50aXplZCxcclxuICAgICAgICAgICAgZW5jb2RlZDogbWVzaGVzWzBdLnN0cnVjdC5lbmNvZGVkLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGF0YTogZGF0YSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3V0ID0gbmV3IE1lc2goKTtcclxuICAgIG91dC5yZXNldChtZXNoQ3JlYXRlSW5mbyk7XHJcbiAgICBvdXQuaGFzaDtcclxuICAgIHJldHVybiBvdXQ7XHJcbn1cclxuIl19