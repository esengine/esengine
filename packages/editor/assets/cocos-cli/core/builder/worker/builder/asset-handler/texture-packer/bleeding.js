"use strict";
// ------------------------------------------------------------------
/// prevents edge artifacts due to bilinear filtering
/// Note: Some image editors like Photoshop tend to fill purely transparent pixel with
/// white color (R=1, G=1, B=1, A=0). This is generally OK, because these white pixels
/// are impossible to see in normal circumstances.  However, when such textures are
/// used in 3D with bilinear filtering, the shader will sometimes sample beyond visible
/// edges into purely transparent pixels and the white color stored there will bleed
/// into the visible edge.  This method scans the texture to find all purely transparent
/// pixels that have a visible neighbor pixel, and copy the color data from that neighbor
/// into the transparent pixel, while preserving its 0 alpha value.  In order to
/// optimize the algorithm for speed of execution, a compromise is made to use any
/// arbitrary neighboring pixel, as this should generally lead to correct results.
/// It also limits itself to the immediate neighbors around the edge, resulting in a
/// a bleed of a single pixel border around the edges, which should be fine, as bilinear
/// filtering should generally not sample beyond that one pixel range.
// ------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
exports.BleedingProcessor = void 0;
class BleedingProcessor {
    // X and Y offsets used in contour bleed for sampling all around each purely transparent pixel
    static applyContourBleed(resultBuffer, srcBuffer, width, rect, sampleXOffsets, sampleYOffsets, bufIdxOffsets) {
        if (rect.width === 0 || rect.height === 0) {
            return;
        }
        const start_x = rect.x;
        const end_x = rect.xMax;
        const start_y = rect.y;
        const end_y = rect.yMax;
        const pixelBytes = 4;
        const ditch = width * pixelBytes;
        let offsetIndex = 0;
        const offsetCount = sampleXOffsets.length;
        let sampleX = 0, sampleY = 0, sampleBufIdx = 0;
        let bufIdx = 0;
        let bufRowStart = start_y * ditch + start_x * pixelBytes;
        for (let y = start_y, x = 0; y < end_y; ++y, bufRowStart += ditch) {
            bufIdx = bufRowStart;
            for (x = start_x; x < end_x; ++x, bufIdx += pixelBytes) {
                // only needs to bleed into purely transparent pixels
                if (srcBuffer[bufIdx + 3] === 0) {
                    // sample all around to find any non-purely transparent pixels
                    for (offsetIndex = 0; offsetIndex < offsetCount; offsetIndex++) {
                        sampleX = x + sampleXOffsets[offsetIndex];
                        sampleY = y + sampleYOffsets[offsetIndex];
                        // check to stay within texture bounds
                        if (sampleX >= start_x && sampleX < end_x && sampleY >= start_y && sampleY < end_y) {
                            sampleBufIdx = bufIdx + bufIdxOffsets[offsetIndex];
                            if (srcBuffer[sampleBufIdx + 3] > 0) {
                                // Copy RGB color channels to purely transparent pixel, but preserving its 0 alpha
                                resultBuffer[bufIdx] = srcBuffer[sampleBufIdx];
                                resultBuffer[bufIdx + 1] = srcBuffer[sampleBufIdx + 1];
                                resultBuffer[bufIdx + 2] = srcBuffer[sampleBufIdx + 2];
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    // ------------------------------------------------------------------
    /// prevents border artifacts due to bilinear filtering
    /// Note: Shaders with bilinear filtering will sometimes sample outside the bounds
    /// of the element, in the padding area, resulting in the padding color to bleed
    /// around the rectangular borders of the element.  This is true even when padding is
    /// purely transparent, because in that case, it is the 0 alpha that bleeds into the
    /// alpha of the outer pixels.  Such alpha bleed is especially problematic when
    /// trying to seamlessly tile multiple rectangular textures, as semi-transparent seams
    /// will sometimes appear at different scales.  This method duplicates a single row of
    /// pixels from the inner border of an element into the padding area.  This technique
    /// can be used with all kinds of textures without risk, even textures with uneven
    /// transparent edges, as it only allows the shader to sample more of the same (opaque
    /// or transparent) values when it exceeds the bounds of the element.
    // ------------------------------------------------------------------
    static applyPaddingBleed(resultBuffer, srcBuffer, width, height, rect) {
        if (rect.width === 0 || rect.height === 0) {
            return;
        }
        const yMin = rect.y;
        const yMax = rect.yMax - 1;
        const xMin = rect.x;
        const xMax = rect.xMax - 1;
        const pixelBytes = 4;
        const ditch = width * pixelBytes;
        const xBufMin = xMin * pixelBytes;
        const xBufMax = xMax * pixelBytes;
        const topRowStart = yMin * ditch;
        const botRowStart = yMax * ditch;
        let bufIdx = 0, bufEnd = 0;
        // copy top row of pixels
        if (yMin - 1 >= 0) {
            bufIdx = topRowStart + xBufMin;
            bufEnd = topRowStart + xBufMax + (pixelBytes - 1);
            for (; bufIdx <= bufEnd; ++bufIdx) {
                resultBuffer[bufIdx - ditch] = srcBuffer[bufIdx];
            }
        }
        // copy bottom row of pixels
        if (yMax + 1 < height) {
            bufIdx = botRowStart + xBufMin;
            bufEnd = botRowStart + xBufMax + (pixelBytes - 1);
            for (; bufIdx <= bufEnd; ++bufIdx) {
                resultBuffer[bufIdx + ditch] = srcBuffer[bufIdx];
            }
        }
        // copy left column of pixels
        if (xMin - 1 >= 0) {
            bufIdx = topRowStart + xBufMin;
            bufEnd = botRowStart + xBufMin;
            for (; bufIdx <= bufEnd; bufIdx += ditch) {
                resultBuffer[bufIdx - 4] = srcBuffer[bufIdx];
                resultBuffer[bufIdx - 3] = srcBuffer[bufIdx + 1];
                resultBuffer[bufIdx - 2] = srcBuffer[bufIdx + 2];
                resultBuffer[bufIdx - 1] = srcBuffer[bufIdx + 3];
            }
        }
        // copy right column of pixels
        if (xMax + 1 < width) {
            bufIdx = topRowStart + xBufMax;
            bufEnd = botRowStart + xBufMax;
            for (; bufIdx <= bufEnd; bufIdx += ditch) {
                resultBuffer[bufIdx + 4] = srcBuffer[bufIdx];
                resultBuffer[bufIdx + 5] = srcBuffer[bufIdx + 1];
                resultBuffer[bufIdx + 6] = srcBuffer[bufIdx + 2];
                resultBuffer[bufIdx + 7] = srcBuffer[bufIdx + 3];
            }
        }
        // copy corners
        if (xMin - 1 >= 0 && yMin - 1 >= 0) {
            for (bufIdx = topRowStart + xBufMin, bufEnd = bufIdx + 4; bufIdx < bufEnd; bufIdx++) {
                resultBuffer[bufIdx - ditch - pixelBytes] = srcBuffer[bufIdx];
            }
        }
        if (xMax + 1 < width && yMin - 1 >= 0) {
            for (bufIdx = topRowStart + xBufMax, bufEnd = bufIdx + 4; bufIdx < bufEnd; bufIdx++) {
                resultBuffer[bufIdx - ditch + pixelBytes] = srcBuffer[bufIdx];
            }
        }
        if (xMin - 1 >= 0 && yMax + 1 < height) {
            for (bufIdx = botRowStart + xBufMin, bufEnd = bufIdx + 4; bufIdx < bufEnd; bufIdx++) {
                resultBuffer[bufIdx + ditch - pixelBytes] = srcBuffer[bufIdx];
            }
        }
        if (xMax + 1 < width && yMax + 1 < height) {
            for (bufIdx = botRowStart + xBufMax, bufEnd = bufIdx + 4; bufIdx < bufEnd; bufIdx++) {
                resultBuffer[bufIdx + ditch + pixelBytes] = srcBuffer[bufIdx];
            }
        }
    }
    static applyBleed(options, atlas, srcBuffer, resultBuffer) {
        let i = 0;
        let tex = null;
        if (options.contourBleed) {
            // init offsets
            const pixelBytes = 4;
            const ditch = atlas.width * pixelBytes;
            // offset
            //   x x x
            //   x o x
            //   x x x
            const sampleXOffsets = [-1, 0, 1, -1, 1, -1, 0, 1];
            const sampleYOffsets = [-1, -1, -1, 0, 0, 1, 1, 1];
            const bufIdxOffsets = [];
            for (let j = 0; j < sampleXOffsets.length; j++) {
                bufIdxOffsets[j] = sampleXOffsets[j] * pixelBytes + sampleYOffsets[j] * ditch;
            }
            // bleed elements
            for (i = 0, tex = null; i < atlas.spriteFrameInfos.length; i++) {
                tex = atlas.spriteFrameInfos[i].trim;
                this.applyContourBleed(resultBuffer, srcBuffer, atlas.width, {
                    x: tex.x,
                    y: tex.y,
                    width: tex.rotatedWidth,
                    height: tex.rotatedHeight,
                    xMax: tex.x + tex.rotatedWidth,
                    yMax: tex.y + tex.rotatedHeight
                }, sampleXOffsets, sampleYOffsets, bufIdxOffsets);
            }
        }
        if (options.paddingBleed) {
            for (i = 0, tex = null; i < atlas.spriteFrameInfos.length; i++) {
                tex = atlas.spriteFrameInfos[i].trim;
                this.applyPaddingBleed(resultBuffer, srcBuffer, atlas.width, atlas.height, {
                    x: tex.x,
                    y: tex.y,
                    width: tex.rotatedWidth,
                    height: tex.rotatedHeight,
                    xMax: tex.x + tex.rotatedWidth,
                    yMax: tex.y + tex.rotatedHeight
                });
            }
        }
    }
}
exports.BleedingProcessor = BleedingProcessor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxlZWRpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvY29yZS9idWlsZGVyL3dvcmtlci9idWlsZGVyL2Fzc2V0LWhhbmRsZXIvdGV4dHVyZS1wYWNrZXIvYmxlZWRpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHFFQUFxRTtBQUNyRSxxREFBcUQ7QUFDckQsc0ZBQXNGO0FBQ3RGLHNGQUFzRjtBQUN0RixtRkFBbUY7QUFDbkYsdUZBQXVGO0FBQ3ZGLG9GQUFvRjtBQUNwRix3RkFBd0Y7QUFDeEYseUZBQXlGO0FBQ3pGLGdGQUFnRjtBQUNoRixrRkFBa0Y7QUFDbEYsa0ZBQWtGO0FBQ2xGLG9GQUFvRjtBQUNwRix3RkFBd0Y7QUFDeEYsc0VBQXNFO0FBQ3RFLHFFQUFxRTs7O0FBNkJyRSxNQUFhLGlCQUFpQjtJQUMxQiw4RkFBOEY7SUFDdEYsTUFBTSxDQUFDLGlCQUFpQixDQUM1QixZQUF3QixFQUN4QixTQUFxQixFQUNyQixLQUFhLEVBQ2IsSUFBVyxFQUNYLGNBQXdCLEVBQ3hCLGNBQXdCLEVBQ3hCLGFBQXVCO1FBRXZCLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN4QyxPQUFPO1FBQ1gsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDdkIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUN4QixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFFeEIsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLE1BQU0sS0FBSyxHQUFHLEtBQUssR0FBRyxVQUFVLENBQUM7UUFDakMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLE1BQU0s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N0QsR0FBRyxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFDckU7b0JBQ0ksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO29CQUNSLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDUixLQUFLLEVBQUUsR0FBRyxDQUFDLFlBQVk7b0JBQ3ZCLE1BQU0sRUFBRSxHQUFHLENBQUMsYUFBYTtvQkFDekIsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFlBQVk7b0JBQzlCLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxhQUFhO2lCQUNsQyxDQUFDLENBQUM7WUFDWCxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7Q0FDSjtBQS9NRCw4Q0ErTUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8vIHByZXZlbnRzIGVkZ2UgYXJ0aWZhY3RzIGR1ZSB0byBiaWxpbmVhciBmaWx0ZXJpbmdcclxuLy8vIE5vdGU6IFNvbWUgaW1hZ2UgZWRpdG9ycyBsaWtlIFBob3Rvc2hvcCB0ZW5kIHRvIGZpbGwgcHVyZWx5IHRyYW5zcGFyZW50IHBpeGVsIHdpdGhcclxuLy8vIHdoaXRlIGNvbG9yIChSPTEsIEc9MSwgQj0xLCBBPTApLiBUaGlzIGlzIGdlbmVyYWxseSBPSywgYmVjYXVzZSB0aGVzZSB3aGl0ZSBwaXhlbHNcclxuLy8vIGFyZSBpbXBvc3NpYmxlIHRvIHNlZSBpbiBub3JtYWwgY2lyY3Vtc3RhbmNlcy4gIEhvd2V2ZXIsIHdoZW4gc3VjaCB0ZXh0dXJlcyBhcmVcclxuLy8vIHVzZWQgaW4gM0Qgd2l0aCBiaWxpbmVhciBmaWx0ZXJpbmcsIHRoZSBzaGFkZXIgd2lsbCBzb21ldGltZXMgc2FtcGxlIGJleW9uZCB2aXNpYmxlXHJcbi8vLyBlZGdlcyBpbnRvIHB1cmVseSB0cmFuc3BhcmVudCBwaXhlbHMgYW5kIHRoZSB3aGl0ZSBjb2xvciBzdG9yZWQgdGhlcmUgd2lsbCBibGVlZFxyXG4vLy8gaW50byB0aGUgdmlzaWJsZSBlZGdlLiAgVGhpcyBtZXRob2Qgc2NhbnMgdGhlIHRleHR1cmUgdG8gZmluZCBhbGwgcHVyZWx5IHRyYW5zcGFyZW50XHJcbi8vLyBwaXhlbHMgdGhhdCBoYXZlIGEgdmlzaWJsZSBuZWlnaGJvciBwaXhlbCwgYW5kIGNvcHkgdGhlIGNvbG9yIGRhdGEgZnJvbSB0aGF0IG5laWdoYm9yXHJcbi8vLyBpbnRvIHRoZSB0cmFuc3BhcmVudCBwaXhlbCwgd2hpbGUgcHJlc2VydmluZyBpdHMgMCBhbHBoYSB2YWx1ZS4gIEluIG9yZGVyIHRvXHJcbi8vLyBvcHRpbWl6ZSB0aGUgYWxnb3JpdGhtIGZvciBzcGVlZCBvZiBleGVjdXRpb24sIGEgY29tcHJvbWlzZSBpcyBtYWRlIHRvIHVzZSBhbnlcclxuLy8vIGFyYml0cmFyeSBuZWlnaGJvcmluZyBwaXhlbCwgYXMgdGhpcyBzaG91bGQgZ2VuZXJhbGx5IGxlYWQgdG8gY29ycmVjdCByZXN1bHRzLlxyXG4vLy8gSXQgYWxzbyBsaW1pdHMgaXRzZWxmIHRvIHRoZSBpbW1lZGlhdGUgbmVpZ2hib3JzIGFyb3VuZCB0aGUgZWRnZSwgcmVzdWx0aW5nIGluIGFcclxuLy8vIGEgYmxlZWQgb2YgYSBzaW5nbGUgcGl4ZWwgYm9yZGVyIGFyb3VuZCB0aGUgZWRnZXMsIHdoaWNoIHNob3VsZCBiZSBmaW5lLCBhcyBiaWxpbmVhclxyXG4vLy8gZmlsdGVyaW5nIHNob3VsZCBnZW5lcmFsbHkgbm90IHNhbXBsZSBiZXlvbmQgdGhhdCBvbmUgcGl4ZWwgcmFuZ2UuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJUmVjdCB7XHJcbiAgICB4OiBudW1iZXI7XHJcbiAgICB5OiBudW1iZXI7XHJcbiAgICB3aWR0aDogbnVtYmVyO1xyXG4gICAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICB4TWF4OiBudW1iZXI7XHJcbiAgICB5TWF4OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUJsZWVkT3B0aW9ucyB7XHJcbiAgICBjb250b3VyQmxlZWQ6IGJvb2xlYW47XHJcbiAgICBwYWRkaW5nQmxlZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUF0bGFzSW5mbyB7XHJcbiAgICB3aWR0aDogbnVtYmVyO1xyXG4gICAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICBzcHJpdGVGcmFtZUluZm9zOiBBcnJheTx7XHJcbiAgICAgICAgdHJpbToge1xyXG4gICAgICAgICAgICB4OiBudW1iZXI7XHJcbiAgICAgICAgICAgIHk6IG51bWJlcjtcclxuICAgICAgICAgICAgcm90YXRlZFdpZHRoOiBudW1iZXI7XHJcbiAgICAgICAgICAgIHJvdGF0ZWRIZWlnaHQ6IG51bWJlcjtcclxuICAgICAgICB9O1xyXG4gICAgfT47XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCbGVlZGluZ1Byb2Nlc3NvciB7XHJcbiAgICAvLyBYIGFuZCBZIG9mZnNldHMgdXNlZCBpbiBjb250b3VyIGJsZWVkIGZvciBzYW1wbGluZyBhbGwgYXJvdW5kIGVhY2ggcHVyZWx5IHRyYW5zcGFyZW50IHBpeGVsXHJcbiAgICBwcml2YXRlIHN0YXRpYyBhcHBseUNvbnRvdXJCbGVlZChcclxuICAgICAgICByZXN1bHRCdWZmZXI6IFVpbnQ4QXJyYXksXHJcbiAgICAgICAgc3JjQnVmZmVyOiBVaW50OEFycmF5LFxyXG4gICAgICAgIHdpZHRoOiBudW1iZXIsXHJcbiAgICAgICAgcmVjdDogSVJlY3QsXHJcbiAgICAgICAgc2FtcGxlWE9mZnNldHM6IG51bWJlcltdLFxyXG4gICAgICAgIHNhbXBsZVlPZmZzZXRzOiBudW1iZXJbXSxcclxuICAgICAgICBidWZJZHhPZmZzZXRzOiBudW1iZXJbXVxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHJlY3Qud2lkdGggPT09IDAgfHwgcmVjdC5oZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRfeCA9IHJlY3QueDtcclxuICAgICAgICBjb25zdCBlbmRfeCA9IHJlY3QueE1heDtcclxuICAgICAgICBjb25zdCBzdGFydF95ID0gcmVjdC55O1xyXG4gICAgICAgIGNvbnN0IGVuZF95ID0gcmVjdC55TWF4O1xyXG5cclxuICAgICAgICBjb25zdCBwaXhlbEJ5dGVzID0gNDtcclxuICAgICAgICBjb25zdCBkaXRjaCA9IHdpZHRoICogcGl4ZWxCeXRlcztcclxuICAgICAgICBsZXQgb2Zmc2V0SW5kZXggPSAwO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldENvdW50ID0gc2FtcGxlWE9mZnNldHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBsZXQgc2FtcGxlWCA9IDAsIHNhbXBsZVkgPSAwLCBzYW1wbGVCdWZJZHggPSAwO1xyXG4gICAgICAgIGxldCBidWZJZHggPSAwO1xyXG4gICAgICAgIGxldCBidWZSb3dTdGFydCA9IHN0YXJ0X3kgKiBkaXRjaCArIHN0YXJ0X3ggKiBwaXhlbEJ5dGVzO1xyXG5cclxuICAgICAgICBmb3IgKGxldCB5ID0gc3RhcnRfeSwgeCA9IDA7IHkgPCBlbmRfeTsgKyt5LCBidWZSb3dTdGFydCArPSBkaXRjaCkge1xyXG4gICAgICAgICAgICBidWZJZHggPSBidWZSb3dTdGFydDtcclxuICAgICAgICAgICAgZm9yICh4ID0gc3RhcnRfeDsgeCA8IGVuZF94OyArK3gsIGJ1ZklkeCArPSBwaXhlbEJ5dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IG5lZWRzIHRvIGJsZWVkIGludG8gcHVyZWx5IHRyYW5zcGFyZW50IHBpeGVsc1xyXG4gICAgICAgICAgICAgICAgaWYgKHNyY0J1ZmZlcltidWZJZHggKyAzXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhbXBsZSBhbGwgYXJvdW5kIHRvIGZpbmQgYW55IG5vbi1wdXJlbHkgdHJhbnNwYXJlbnQgcGl4ZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChvZmZzZXRJbmRleCA9IDA7IG9mZnNldEluZGV4IDwgb2Zmc2V0Q291bnQ7IG9mZnNldEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlWCA9IHggKyBzYW1wbGVYT2Zmc2V0c1tvZmZzZXRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVkgPSB5ICsgc2FtcGxlWU9mZnNldHNbb2Zmc2V0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzdGF5IHdpdGhpbiB0ZXh0dXJlIGJvdW5kc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2FtcGxlWCA+PSBzdGFydF94ICYmIHNhbXBsZVggPCBlbmRfeCAmJiBzYW1wbGVZID49IHN0YXJ0X3kgJiYgc2FtcGxlWSA8IGVuZF95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVCdWZJZHggPSBidWZJZHggKyBidWZJZHhPZmZzZXRzW29mZnNldEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmNCdWZmZXJbc2FtcGxlQnVmSWR4ICsgM10gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBSR0IgY29sb3IgY2hhbm5lbHMgdG8gcHVyZWx5IHRyYW5zcGFyZW50IHBpeGVsLCBidXQgcHJlc2VydmluZyBpdHMgMCBhbHBoYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEJ1ZmZlcltidWZJZHhdID0gc3JjQnVmZmVyW3NhbXBsZUJ1ZklkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0QnVmZmVyW2J1ZklkeCArIDFdID0gc3JjQnVmZmVyW3NhbXBsZUJ1ZklkeCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEJ1ZmZlcltidWZJZHggKyAyXSA9IHNyY0J1ZmZlcltzYW1wbGVCdWZJZHggKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vLyBwcmV2ZW50cyBib3JkZXIgYXJ0aWZhY3RzIGR1ZSB0byBiaWxpbmVhciBmaWx0ZXJpbmdcclxuICAgIC8vLyBOb3RlOiBTaGFkZXJzIHdpdGggYmlsaW5lYXIgZmlsdGVyaW5nIHdpbGwgc29tZXRpbWVzIHNhbXBsZSBvdXRzaWRlIHRoZSBib3VuZHNcclxuICAgIC8vLyBvZiB0aGUgZWxlbWVudCwgaW4gdGhlIHBhZGRpbmcgYXJlYSwgcmVzdWx0aW5nIGluIHRoZSBwYWRkaW5nIGNvbG9yIHRvIGJsZWVkXHJcbiAgICAvLy8gYXJvdW5kIHRoZSByZWN0YW5ndWxhciBib3JkZXJzIG9mIHRoZSBlbGVtZW50LiAgVGhpcyBpcyB0cnVlIGV2ZW4gd2hlbiBwYWRkaW5nIGlzXHJcbiAgICAvLy8gcHVyZWx5IHRyYW5zcGFyZW50LCBiZWNhdXNlIGluIHRoYXQgY2FzZSwgaXQgaXMgdGhlIDAgYWxwaGEgdGhhdCBibGVlZHMgaW50byB0aGVcclxuICAgIC8vLyBhbHBoYSBvZiB0aGUgb3V0ZXIgcGl4ZWxzLiAgU3VjaCBhbHBoYSBibGVlZCBpcyBlc3BlY2lhbGx5IHByb2JsZW1hdGljIHdoZW5cclxuICAgIC8vLyB0cnlpbmcgdG8gc2VhbWxlc3NseSB0aWxlIG11bHRpcGxlIHJlY3Rhbmd1bGFyIHRleHR1cmVzLCBhcyBzZW1pLXRyYW5zcGFyZW50IHNlYW1zXHJcbiAgICAvLy8gd2lsbCBzb21ldGltZXMgYXBwZWFyIGF0IGRpZmZlcmVudCBzY2FsZXMuICBUaGlzIG1ldGhvZCBkdXBsaWNhdGVzIGEgc2luZ2xlIHJvdyBvZlxyXG4gICAgLy8vIHBpeGVscyBmcm9tIHRoZSBpbm5lciBib3JkZXIgb2YgYW4gZWxlbWVudCBpbnRvIHRoZSBwYWRkaW5nIGFyZWEuICBUaGlzIHRlY2huaXF1ZVxyXG4gICAgLy8vIGNhbiBiZSB1c2VkIHdpdGggYWxsIGtpbmRzIG9mIHRleHR1cmVzIHdpdGhvdXQgcmlzaywgZXZlbiB0ZXh0dXJlcyB3aXRoIHVuZXZlblxyXG4gICAgLy8vIHRyYW5zcGFyZW50IGVkZ2VzLCBhcyBpdCBvbmx5IGFsbG93cyB0aGUgc2hhZGVyIHRvIHNhbXBsZSBtb3JlIG9mIHRoZSBzYW1lIChvcGFxdWVcclxuICAgIC8vLyBvciB0cmFuc3BhcmVudCkgdmFsdWVzIHdoZW4gaXQgZXhjZWVkcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBwcml2YXRlIHN0YXRpYyBhcHBseVBhZGRpbmdCbGVlZChcclxuICAgICAgICByZXN1bHRCdWZmZXI6IFVpbnQ4QXJyYXksXHJcbiAgICAgICAgc3JjQnVmZmVyOiBVaW50OEFycmF5LFxyXG4gICAgICAgIHdpZHRoOiBudW1iZXIsXHJcbiAgICAgICAgaGVpZ2h0OiBudW1iZXIsXHJcbiAgICAgICAgcmVjdDogSVJlY3RcclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGlmIChyZWN0LndpZHRoID09PSAwIHx8IHJlY3QuaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHlNaW4gPSByZWN0Lnk7XHJcbiAgICAgICAgY29uc3QgeU1heCA9IHJlY3QueU1heCAtIDE7XHJcbiAgICAgICAgY29uc3QgeE1pbiA9IHJlY3QueDtcclxuICAgICAgICBjb25zdCB4TWF4ID0gcmVjdC54TWF4IC0gMTtcclxuXHJcbiAgICAgICAgY29uc3QgcGl4ZWxCeXRlcyA9IDQ7XHJcbiAgICAgICAgY29uc3QgZGl0Y2ggPSB3aWR0aCAqIHBpeGVsQnl0ZXM7XHJcbiAgICAgICAgY29uc3QgeEJ1Zk1pbiA9IHhNaW4gKiBwaXhlbEJ5dGVzO1xyXG4gICAgICAgIGNvbnN0IHhCdWZNYXggPSB4TWF4ICogcGl4ZWxCeXRlcztcclxuICAgICAgICBjb25zdCB0b3BSb3dTdGFydCA9IHlNaW4gKiBkaXRjaDtcclxuICAgICAgICBjb25zdCBib3RSb3dTdGFydCA9IHlNYXggKiBkaXRjaDtcclxuXHJcbiAgICAgICAgbGV0IGJ1ZklkeCA9IDAsIGJ1ZkVuZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIGNvcHkgdG9wIHJvdyBvZiBwaXhlbHNcclxuICAgICAgICBpZiAoeU1pbiAtIDEgPj0gMCkge1xyXG4gICAgICAgICAgICBidWZJZHggPSB0b3BSb3dTdGFydCArIHhCdWZNaW47XHJcbiAgICAgICAgICAgIGJ1ZkVuZCA9IHRvcFJvd1N0YXJ0ICsgeEJ1Zk1heCArIChwaXhlbEJ5dGVzIC0gMSk7XHJcbiAgICAgICAgICAgIGZvciAoOyBidWZJZHggPD0gYnVmRW5kOyArK2J1ZklkeCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0QnVmZmVyW2J1ZklkeCAtIGRpdGNoXSA9IHNyY0J1ZmZlcltidWZJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvcHkgYm90dG9tIHJvdyBvZiBwaXhlbHNcclxuICAgICAgICBpZiAoeU1heCArIDEgPCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgYnVmSWR4ID0gYm90Um93U3RhcnQgKyB4QnVmTWluO1xyXG4gICAgICAgICAgICBidWZFbmQgPSBib3RSb3dTdGFydCArIHhCdWZNYXggKyAocGl4ZWxCeXRlcyAtIDEpO1xyXG4gICAgICAgICAgICBmb3IgKDsgYnVmSWR4IDw9IGJ1ZkVuZDsgKytidWZJZHgpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdEJ1ZmZlcltidWZJZHggKyBkaXRjaF0gPSBzcmNCdWZmZXJbYnVmSWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb3B5IGxlZnQgY29sdW1uIG9mIHBpeGVsc1xyXG4gICAgICAgIGlmICh4TWluIC0gMSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGJ1ZklkeCA9IHRvcFJvd1N0YXJ0ICsgeEJ1Zk1pbjtcclxuICAgICAgICAgICAgYnVmRW5kID0gYm90Um93U3RhcnQgKyB4QnVmTWluO1xyXG4gICAgICAgICAgICBmb3IgKDsgYnVmSWR4IDw9IGJ1ZkVuZDsgYnVmSWR4ICs9IGRpdGNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXJbYnVmSWR4IC0gNF0gPSBzcmNCdWZmZXJbYnVmSWR4XTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdEJ1ZmZlcltidWZJZHggLSAzXSA9IHNyY0J1ZmZlcltidWZJZHggKyAxXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdEJ1ZmZlcltidWZJZHggLSAyXSA9IHNyY0J1ZmZlcltidWZJZHggKyAyXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdEJ1ZmZlcltidWZJZHggLSAxXSA9IHNyY0J1ZmZlcltidWZJZHggKyAzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb3B5IHJpZ2h0IGNvbHVtbiBvZiBwaXhlbHNcclxuICAgICAgICBpZiAoeE1heCArIDEgPCB3aWR0aCkge1xyXG4gICAgICAgICAgICBidWZJZHggPSB0b3BSb3dTdGFydCArIHhCdWZNYXg7XHJcbiAgICAgICAgICAgIGJ1ZkVuZCA9IGJvdFJvd1N0YXJ0ICsgeEJ1Zk1heDtcclxuICAgICAgICAgICAgZm9yICg7IGJ1ZklkeCA8PSBidWZFbmQ7IGJ1ZklkeCArPSBkaXRjaCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0QnVmZmVyW2J1ZklkeCArIDRdID0gc3JjQnVmZmVyW2J1ZklkeF07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXJbYnVmSWR4ICsgNV0gPSBzcmNCdWZmZXJbYnVmSWR4ICsgMV07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXJbYnVmSWR4ICsgNl0gPSBzcmNCdWZmZXJbYnVmSWR4ICsgMl07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXJbYnVmSWR4ICsgN10gPSBzcmNCdWZmZXJbYnVmSWR4ICsgM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29weSBjb3JuZXJzXHJcbiAgICAgICAgaWYgKHhNaW4gLSAxID49IDAgJiYgeU1pbiAtIDEgPj0gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGJ1ZklkeCA9IHRvcFJvd1N0YXJ0ICsgeEJ1Zk1pbiwgYnVmRW5kID0gYnVmSWR4ICsgNDsgYnVmSWR4IDwgYnVmRW5kOyBidWZJZHgrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0QnVmZmVyW2J1ZklkeCAtIGRpdGNoIC0gcGl4ZWxCeXRlc10gPSBzcmNCdWZmZXJbYnVmSWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeE1heCArIDEgPCB3aWR0aCAmJiB5TWluIC0gMSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGZvciAoYnVmSWR4ID0gdG9wUm93U3RhcnQgKyB4QnVmTWF4LCBidWZFbmQgPSBidWZJZHggKyA0OyBidWZJZHggPCBidWZFbmQ7IGJ1ZklkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXJbYnVmSWR4IC0gZGl0Y2ggKyBwaXhlbEJ5dGVzXSA9IHNyY0J1ZmZlcltidWZJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4TWluIC0gMSA+PSAwICYmIHlNYXggKyAxIDwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGZvciAoYnVmSWR4ID0gYm90Um93U3RhcnQgKyB4QnVmTWluLCBidWZFbmQgPSBidWZJZHggKyA0OyBidWZJZHggPCBidWZFbmQ7IGJ1ZklkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXJbYnVmSWR4ICsgZGl0Y2ggLSBwaXhlbEJ5dGVzXSA9IHNyY0J1ZmZlcltidWZJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4TWF4ICsgMSA8IHdpZHRoICYmIHlNYXggKyAxIDwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGZvciAoYnVmSWR4ID0gYm90Um93U3RhcnQgKyB4QnVmTWF4LCBidWZFbmQgPSBidWZJZHggKyA0OyBidWZJZHggPCBidWZFbmQ7IGJ1ZklkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXJbYnVmSWR4ICsgZGl0Y2ggKyBwaXhlbEJ5dGVzXSA9IHNyY0J1ZmZlcltidWZJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXBwbHlCbGVlZChvcHRpb25zOiBJQmxlZWRPcHRpb25zLCBhdGxhczogSUF0bGFzSW5mbywgc3JjQnVmZmVyOiBVaW50OEFycmF5LCByZXN1bHRCdWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IHRleDogYW55ID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udG91ckJsZWVkKSB7XHJcbiAgICAgICAgICAgIC8vIGluaXQgb2Zmc2V0c1xyXG4gICAgICAgICAgICBjb25zdCBwaXhlbEJ5dGVzID0gNDtcclxuICAgICAgICAgICAgY29uc3QgZGl0Y2ggPSBhdGxhcy53aWR0aCAqIHBpeGVsQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBvZmZzZXRcclxuICAgICAgICAgICAgLy8gICB4IHggeFxyXG4gICAgICAgICAgICAvLyAgIHggbyB4XHJcbiAgICAgICAgICAgIC8vICAgeCB4IHhcclxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlWE9mZnNldHMgPSBbLTEsIDAsIDEsIC0xLCAxLCAtMSwgMCwgMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVlPZmZzZXRzID0gWy0xLCAtMSwgLTEsIDAsIDAsIDEsIDEsIDFdO1xyXG4gICAgICAgICAgICBjb25zdCBidWZJZHhPZmZzZXRzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzYW1wbGVYT2Zmc2V0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYnVmSWR4T2Zmc2V0c1tqXSA9IHNhbXBsZVhPZmZzZXRzW2pdICogcGl4ZWxCeXRlcyArIHNhbXBsZVlPZmZzZXRzW2pdICogZGl0Y2g7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGJsZWVkIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIHRleCA9IG51bGw7IGkgPCBhdGxhcy5zcHJpdGVGcmFtZUluZm9zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXggPSBhdGxhcy5zcHJpdGVGcmFtZUluZm9zW2ldLnRyaW07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Q29udG91ckJsZWVkKHJlc3VsdEJ1ZmZlciwgc3JjQnVmZmVyLCBhdGxhcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRleC54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0ZXgueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRleC5yb3RhdGVkV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGV4LnJvdGF0ZWRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhNYXg6IHRleC54ICsgdGV4LnJvdGF0ZWRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeU1heDogdGV4LnkgKyB0ZXgucm90YXRlZEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlWE9mZnNldHMsIHNhbXBsZVlPZmZzZXRzLCBidWZJZHhPZmZzZXRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGFkZGluZ0JsZWVkKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIHRleCA9IG51bGw7IGkgPCBhdGxhcy5zcHJpdGVGcmFtZUluZm9zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXggPSBhdGxhcy5zcHJpdGVGcmFtZUluZm9zW2ldLnRyaW07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UGFkZGluZ0JsZWVkKHJlc3VsdEJ1ZmZlciwgc3JjQnVmZmVyLCBhdGxhcy53aWR0aCwgYXRsYXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGV4LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRleC55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGV4LnJvdGF0ZWRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXgucm90YXRlZEhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeE1heDogdGV4LnggKyB0ZXgucm90YXRlZFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TWF4OiB0ZXgueSArIHRleC5yb3RhdGVkSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19