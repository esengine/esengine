<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ccesengine Viewport</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
        }
        #GameDiv {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #Cocos3dGameContainer {
            width: 100%;
            height: 100%;
        }
        #GameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-family: monospace;
            font-size: 14px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: monospace;
            font-size: 14px;
            max-width: 80%;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <div id="GameDiv">
        <div id="Cocos3dGameContainer">
            <canvas id="GameCanvas"></canvas>
        </div>
    </div>
    <div id="loading">Loading ccesengine...</div>
    <div id="error"></div>

    <script type="module">
        /**
         * @zh ccesengine 视口初始化脚本（嵌入式版本）
         * @en ccesengine viewport initialization script (embedded version)
         *
         * 使用 asset:// 自定义协议从本地文件系统加载模块。
         * Uses asset:// custom protocol to load modules from local filesystem.
         */

        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');

        function showError(message) {
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            errorEl.textContent = message;
            sendIPC({ type: 'Error', message });
        }

        function showStatus(message) {
            loadingEl.textContent = message;
            sendIPC({ type: 'Status', message });
        }

        function sendIPC(data) {
            if (window.ipc && window.ipc.postMessage) {
                window.ipc.postMessage(JSON.stringify(data));
            }
        }

        // Forward console logs to IPC for debugging
        const originalConsole = {
            log: console.log.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console)
        };

        console.log = (...args) => {
            originalConsole.log(...args);
            sendIPC({ type: 'ConsoleLog', message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ') });
        };

        console.warn = (...args) => {
            originalConsole.warn(...args);
            sendIPC({ type: 'ConsoleWarn', message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ') });
        };

        console.error = (...args) => {
            originalConsole.error(...args);
            sendIPC({ type: 'ConsoleError', message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ') });
        };

        // Engine state
        let cc = null;
        let game = null;
        let director = null;
        let scene = null;

        // Load modules using asset:// protocol
        const MODULES = [
            'base',
            'gfx-webgl2',
            'legacy-pipeline',
            '2d',
            'ui',
            '3d',
            'primitive',
            'graphics',  // Required for grid drawing
            'geometry-renderer'  // Required for 3D line rendering (GeometryRenderer)
        ];

        async function loadModules() {
            showStatus('Loading modules...');

            for (const module of MODULES) {
                try {
                    showStatus(`Loading ${module}...`);
                    // Use asset:// custom protocol to load from local filesystem
                    const imported = await import(`asset://localhost/ccesengine/${module}.js`);

                    if (module === 'base') {
                        cc = imported.cclegacy;
                        window.cc = cc;
                        game = cc.game;
                        director = cc.director;
                    } else {
                        // Merge module exports into cc
                        for (const [key, value] of Object.entries(imported)) {
                            if (key.startsWith('_') || key === 'default' || key === 'cclegacy') continue;
                            if (typeof value === 'function' || (typeof value === 'object' && value !== null)) {
                                if (!(key in cc)) {
                                    cc[key] = value;
                                }
                            }
                        }
                    }
                } catch (error) {
                    throw new Error(`Failed to load module ${module}: ${error.message}`);
                }
            }
        }

        /**
         * @zh 等待内置 effects 数据注入
         * @en Wait for builtin effects data injection
         */
        async function waitForBuiltinEffects(timeoutMs = 5000) {
            showStatus('Waiting for builtin effects...');
            const startTime = Date.now();

            return new Promise((resolve) => {
                const check = () => {
                    if (window.__BUILTIN_EFFECTS__) {
                        resolve(window.__BUILTIN_EFFECTS__);
                    } else if (Date.now() - startTime > timeoutMs) {
                        console.warn('[ccesengine] Timeout waiting for builtin effects, proceeding without them');
                        resolve(null);
                    } else {
                        requestAnimationFrame(check);
                    }
                };
                check();
            });
        }

        /**
         * @zh 注册编译好的 effects 到引擎
         * @en Register compiled effects to engine
         */
        function registerBuiltinEffects(effectsData) {
            if (!effectsData || !Array.isArray(effectsData)) {
                console.warn('[ccesengine] No effects data to register');
                return;
            }

            showStatus('Registering effects...');

            const EffectAsset = cc.EffectAsset;
            const programLib = cc.programLib;

            if (!EffectAsset) {
                return;
            }

            // Store graphics effect for later material creation
            let graphicsEffect = null;

            for (const effectData of effectsData) {
                try {

                    // Create EffectAsset instance
                    const effect = new EffectAsset();
                    effect._name = effectData.name;
                    effect.name = effectData.name;
                    effect._uuid = `builtin-effect-${effectData.name}`;

                    // Set techniques and shaders from compiled data
                    effect.techniques = effectData.techniques || [];
                    effect.shaders = effectData.shaders || [];
                    effect.combinations = effectData.combinations || [];

                    // Ensure each technique pass has required fields
                    for (const tech of effect.techniques) {
                        for (const pass of tech.passes || []) {
                            // Ensure propertyIndex exists (default to 0)
                            if (pass.propertyIndex === undefined) {
                                pass.propertyIndex = 0;
                            }
                            // Ensure embeddedMacros exists
                            if (!pass.embeddedMacros) {
                                pass.embeddedMacros = {};
                            }
                        }
                    }

                    // Register with programLib (shader compilation)
                    if (programLib?.register) {
                        programLib.register(effect);
                    }

                    // Call onLoaded if available
                    if (effect.onLoaded) {
                        effect.onLoaded();
                    }

                    // Register to EffectAsset static map
                    if (EffectAsset.register) {
                        EffectAsset.register(effect);
                    }

                    // Store graphics effect for later
                    if (effectData.name === 'internal/builtin-graphics' || effectData.name === 'builtin-graphics') {
                        graphicsEffect = effect;
                    }
                } catch (error) {
                    console.error(`[ccesengine] Failed to register effect ${effectData.name}:`, error);
                }
            }

            // Re-initialize GeometryRenderer materials now that effects are registered
            try {
                const pipelineSceneData = director?.root?.pipeline?.pipelineSceneData;
                if (pipelineSceneData?.initGeometryRendererMaterials) {
                    pipelineSceneData.initGeometryRendererMaterials();
                }
            } catch (geoMatError) {
                // Silently ignore if not available
            }

            // Create graphics material SYNCHRONOUSLY after all effects are registered
            // This must happen before any Graphics components are created
            if (graphicsEffect) {
                createGraphicsMaterial(graphicsEffect);
            }
        }

        /**
         * @zh 创建 Graphics 组件所需的材质
         * @en Create material required by Graphics component
         */
        function createGraphicsMaterial(effect) {
            try {
                const Material = cc.Material;
                const builtinResMgr = cc.builtinResMgr;

                if (!Material || !builtinResMgr || !effect) return;

                // Create material from effect
                const material = new Material();
                material._uuid = 'ui-graphics-material';
                material._name = 'ui-graphics-material';

                try {
                    material.initialize({ effectAsset: effect });
                } catch (initError) {
                    // Try alternative initialization
                    material.initialize({ effectAsset: effect, technique: 0 });
                }

                // Register if material has passes
                if (material.passes?.length > 0 && builtinResMgr.addAsset) {
                    builtinResMgr.addAsset('ui-graphics-material', material);
                }
            } catch (error) {
                console.error('[ccesengine] Failed to create graphics material:', error);
            }
        }

        async function initGame() {
            showStatus('Initializing game...');

            try {
                // Set up timeout for init
                const initPromise = game.init({
                    debugMode: 1,
                    showFPS: false,
                    frameRate: 60,
                    overrideSettings: {
                        rendering: {
                            renderMode: 2,
                            customPipeline: false,
                        },
                    },
                });

                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('game.init() timeout after 10s')), 10000);
                });

                await Promise.race([initPromise, timeoutPromise]);
            } catch (initError) {
                console.error('[ccesengine] game.init() failed:', initError);
                throw initError;
            }
        }

        async function runGame() {
            showStatus('Starting game...');
            game.run();

            // Wait for director.root to be ready
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => reject(new Error('Engine ready timeout')), 5000);
                const check = () => {
                    if (director?.root) {
                        clearTimeout(timeout);
                        resolve();
                    } else {
                        requestAnimationFrame(check);
                    }
                };
                requestAnimationFrame(check);
            });

            // Patch the shader compilation to filter reserved GLSL macros
            patchShaderCompilation();
        }

        /**
         * @zh 修补着色器编译以过滤保留的 GLSL 宏
         * @en Patch shader compilation to filter reserved GLSL macros
         */
        function patchShaderCompilation() {
            const device = director?.root?.device || cc.gfx?.deviceManager?.gfxDevice;
            if (!device) return;

            // Reserved GLSL macros that cannot be redefined
            const reservedMacros = [
                '__VERSION__',
                'GL_ES',
                'GL_OES_standard_derivatives',
                'GL_EXT_draw_buffers',
                'GL_EXT_frag_depth',
                'GL_EXT_shader_texture_lod',
            ];

            // Create a regex to match and remove these defines
            const reservedDefineRegex = new RegExp(
                `^\\s*#define\\s+(${reservedMacros.join('|')})\\s+.*$`,
                'gm'
            );

            // Try to patch createShader method
            const originalCreateShader = device.createShader?.bind(device);
            if (originalCreateShader) {
                device.createShader = function(shaderInfo) {
                    // Filter reserved macros from vertex and fragment shaders
                    const filteredInfo = { ...shaderInfo };

                    if (filteredInfo.stages) {
                        filteredInfo.stages = filteredInfo.stages.map(stage => {
                            if (stage.source && typeof stage.source === 'string') {
                                const filteredSource = stage.source.replace(reservedDefineRegex, '// [REMOVED RESERVED MACRO]');
                                return { ...stage, source: filteredSource };
                            }
                            return stage;
                        });
                    }

                    return originalCreateShader(filteredInfo);
                };
            }

            // Also try to patch the programLib's getGLSLSource if available
            const programLib = cc.programLib;
            if (programLib) {
                const originalGetGLSLSource = programLib.getGLSLSource?.bind(programLib);
                if (originalGetGLSLSource) {
                    programLib.getGLSLSource = function(...args) {
                        const result = originalGetGLSLSource(...args);
                        if (result && typeof result === 'object') {
                            if (result.vert) {
                                result.vert = result.vert.replace(reservedDefineRegex, '// [REMOVED RESERVED MACRO]');
                            }
                            if (result.frag) {
                                result.frag = result.frag.replace(reservedDefineRegex, '// [REMOVED RESERVED MACRO]');
                            }
                        }
                        return result;
                    };
                }
            }
        }

        function createDefaultScene() {
            showStatus('Creating scene...');

            // Create empty scene
            scene = new cc.Scene('EditorScene');
            scene._inited = true;

            // Create camera node
            const cameraNode = new cc.Node('Main Camera');
            cameraNode.setPosition(0, 0, 10);
            scene.addChild(cameraNode);

            // Add camera component
            const Camera = cc.Camera;
            if (Camera) {
                const camera = cameraNode.addComponent(Camera);
                camera.clearFlags = cc.Camera?.ClearFlag?.SOLID_COLOR ?? 7;
                // Use dark gray background (editor style)
                camera.clearColor = cc.color('#2d2d2d');
                camera.projection = 1; // Orthographic
                camera.orthoHeight = 5;
            }

            // Run scene
            director.runSceneImmediate(scene);
        }

        function handleResize() {
            const canvas = document.getElementById('GameCanvas');
            const width = window.innerWidth;
            const height = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;

            // Update canvas physical and CSS size
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;

            // Update engine root
            if (director?.root) {
                director.root.resize(canvas.width, canvas.height);
            }

            // Update main camera ortho height for 3D scene
            if (mainCameraComp) {
                mainCameraComp.orthoHeight = height / 2 / 100; // Divide by 100 for world units
            }
        }

        // IPC command handlers
        const commandHandlers = {
            resize: (data) => {
                handleResize();
            },
            createNode: (data) => {
                if (!scene) return { error: 'No scene' };
                const node = new cc.Node(data.name || 'New Node');
                if (data.position) {
                    node.setPosition(data.position.x || 0, data.position.y || 0, data.position.z || 0);
                }
                scene.addChild(node);
                return { nodeId: node.uuid };
            },
            getSceneInfo: () => {
                if (!scene) return { error: 'No scene' };
                const nodes = [];
                scene.children.forEach(child => {
                    nodes.push({
                        uuid: child.uuid,
                        name: child.name,
                        position: {
                            x: child.position.x,
                            y: child.position.y,
                            z: child.position.z,
                        }
                    });
                });
                return { sceneName: scene.name, nodes };
            },
        };

        // Handle IPC messages from egui
        window.handleIPCCommand = function(commandJson) {
            try {
                const command = JSON.parse(commandJson);
                const handler = commandHandlers[command.type];
                if (handler) {
                    const result = handler(command.data);
                    return JSON.stringify({ success: true, result });
                } else {
                    return JSON.stringify({ success: false, error: `Unknown command: ${command.type}` });
                }
            } catch (error) {
                return JSON.stringify({ success: false, error: error.message });
            }
        };

        // Main initialization
        async function main() {
            try {
                await loadModules();
                await initGame();
                await runGame();

                // Wait for and register builtin effects (for Graphics component)
                const effectsData = await waitForBuiltinEffects(3000);
                if (effectsData) {
                    registerBuiltinEffects(effectsData);
                }

                createDefaultScene();

                // Setup 3D grid rendering using GeometryRenderer
                setupGridRendering();

                // Setup resize handler
                window.addEventListener('resize', handleResize);
                handleResize();

                // Hide loading
                loadingEl.style.display = 'none';

                sendIPC({ type: 'Ready', message: 'ccesengine initialized successfully' });

            } catch (error) {
                console.error('Initialization failed:', error);
                showError(error.message);
            }
        }

        // Store geometry renderer reference
        let geometryRenderer = null;
        let mainCameraComp = null;

        /**
         * @zh 初始化 GeometryRenderer 用于 3D 网格绘制
         * @en Initialize GeometryRenderer for 3D grid drawing
         *
         * Camera 组件有一个 .camera 属性指向内部渲染 camera，
         * initGeometryRenderer 方法在内部 camera 上，不是组件上。
         *
         * The Camera component has a .camera property pointing to the internal render camera.
         * The initGeometryRenderer method is on the internal camera, not the component.
         */
        function initGeometryRenderer() {
            // Get the main camera from scene
            const cameraNode = scene.getChildByName('Main Camera');
            if (!cameraNode) return false;

            mainCameraComp = cameraNode.getComponent(cc.Camera);
            if (!mainCameraComp) return false;

            // Get internal render camera from Camera component
            const internalCamera = mainCameraComp.camera;
            if (!internalCamera) return false;

            // Initialize geometry renderer on internal camera
            if (typeof internalCamera.initGeometryRenderer === 'function') {
                internalCamera.initGeometryRenderer();
                geometryRenderer = internalCamera.geometryRenderer;
                return !!geometryRenderer;
            }
            return false;
        }

        /**
         * @zh 使用 GeometryRenderer 绘制 3D 网格
         * @en Draw 3D grid using GeometryRenderer
         */
        function drawGrid() {
            if (!geometryRenderer) return;

            const Vec3 = cc.Vec3;
            const Color = cc.Color;

            // Grid parameters
            const gridSize = 1;        // 1 unit spacing
            const gridExtent = 10;     // -10 to 10 units
            const v0 = new Vec3();
            const v1 = new Vec3();

            // Grid color (gray)
            const gridColor = new Color(80, 80, 80, 200);

            // Draw grid lines on XY plane (Z=0)
            for (let i = -gridExtent; i <= gridExtent; i++) {
                if (i === 0) continue; // Skip axis
                // Vertical lines (along Y)
                v0.set(i * gridSize, -gridExtent * gridSize, 0);
                v1.set(i * gridSize, gridExtent * gridSize, 0);
                geometryRenderer.addLine(v0, v1, gridColor, false);

                // Horizontal lines (along X)
                v0.set(-gridExtent * gridSize, i * gridSize, 0);
                v1.set(gridExtent * gridSize, i * gridSize, 0);
                geometryRenderer.addLine(v0, v1, gridColor, false);
            }

            // X axis (red)
            const xAxisColor = new Color(220, 60, 60, 255);
            v0.set(-gridExtent * gridSize, 0, 0);
            v1.set(gridExtent * gridSize, 0, 0);
            geometryRenderer.addLine(v0, v1, xAxisColor, false);

            // Y axis (green)
            const yAxisColor = new Color(60, 180, 60, 255);
            v0.set(0, -gridExtent * gridSize, 0);
            v1.set(0, gridExtent * gridSize, 0);
            geometryRenderer.addLine(v0, v1, yAxisColor, false);

            // Z axis (blue) - shorter since we're looking at XY plane
            const zAxisColor = new Color(60, 60, 220, 255);
            v0.set(0, 0, -5);
            v1.set(0, 0, 5);
            geometryRenderer.addLine(v0, v1, zAxisColor, false);
        }

        /**
         * @zh 设置渲染循环中的网格绘制
         * @en Setup grid drawing in render loop
         *
         * 内部 camera 可能需要几帧才能准备好，所以需要重试机制。
         * The internal camera may take a few frames to be ready, so retry is needed.
         */
        function setupGridRendering() {
            let retryCount = 0;
            const maxRetries = 30;

            function tryInit() {
                if (initGeometryRenderer()) {
                    // Register to draw grid every frame before rendering
                    director.on(cc.Director.EVENT_BEFORE_DRAW, drawGrid);
                } else if (retryCount < maxRetries) {
                    retryCount++;
                    requestAnimationFrame(tryInit);
                }
            }

            tryInit();
        }

        main();
    </script>
</body>
</html>
