<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ccesengine Viewport</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
        }
        #GameDiv {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #Cocos3dGameContainer {
            width: 100%;
            height: 100%;
        }
        #GameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-family: monospace;
            font-size: 14px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: monospace;
            font-size: 14px;
            max-width: 80%;
            text-align: center;
            display: none;
        }
        #axisIndicator {
            position: absolute;
            bottom: 16px;
            left: 16px;
            width: 80px;
            height: 80px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="GameDiv">
        <div id="Cocos3dGameContainer">
            <canvas id="GameCanvas"></canvas>
        </div>
    </div>
    <div id="loading">Loading ccesengine...</div>
    <div id="error"></div>
    <canvas id="axisIndicator" width="160" height="160"></canvas>

    <!-- Load viewport RPC module -->
    <script src="asset://localhost/viewport-rpc.js"></script>

    <script type="module">
        /**
         * @zh ccesengine 视口初始化脚本（嵌入式版本）
         * @en ccesengine viewport initialization script (embedded version)
         *
         * 使用 asset:// 自定义协议从本地文件系统加载模块。
         * Uses asset:// custom protocol to load modules from local filesystem.
         */

        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');

        /** @type {ViewportRpc.ViewportRpcHandler} */
        let rpc = null;

        if (window.ViewportRpc) {
            rpc = window.ViewportRpc.createViewportRpc({
                send: (msg) => {
                    if (window.ipc?.postMessage) {
                        window.ipc.postMessage(msg);
                    }
                }
            });

            // Expose handleRpcMessage for incoming messages from editor
            window.handleRpcMessage = (data) => rpc.handleMessage(data);
        } else {
            console.error('[Viewport] ViewportRpc not loaded!');
        }


        function showError(message) {
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            errorEl.textContent = message;
            rpc?.emitError(message);
        }

        function showStatus(message) {
            loadingEl.textContent = message;
            // Status is just for loading, use log
            rpc?.emitLog('info', message);
        }

        const originalConsole = {
            log: console.log.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console)
        };

        function sendLogFallback(level, message) {
            if (rpc) {
                rpc.emitLog(level, message);
            } else if (window.ipc?.postMessage) {
                window.ipc.postMessage(JSON.stringify({
                    jsonrpc: "2.0",
                    method: "viewport.log",
                    params: { level, message }
                }));
            }
        }

        console.log = (...args) => {
            originalConsole.log(...args);
            const message = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
            sendLogFallback('info', message);
        };

        console.warn = (...args) => {
            originalConsole.warn(...args);
            const message = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
            sendLogFallback('warn', message);
        };

        console.error = (...args) => {
            originalConsole.error(...args);
            const message = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
            sendLogFallback('error', message);
        };

        // Engine state
        let cc = null;
        let game = null;
        let director = null;
        let scene = null;

        // Project configuration
        let projectServerUrl = null;
        let projectLibraryUrl = null;

        // View mode: '2d' or '3d'
        let viewMode = '3d';

        // EditorExtends simulation (minimal implementation for scene loading)
        const EditorExtends = {
            Node: {
                _pathCache: new Map(),
                getNodePath(node) {
                    if (!node) return '';
                    if (this._pathCache.has(node.uuid)) {
                        return this._pathCache.get(node.uuid);
                    }
                    const path = this._buildNodePath(node);
                    this._pathCache.set(node.uuid, path);
                    return path;
                },
                _buildNodePath(node) {
                    const parts = [];
                    let current = node;
                    while (current && current.parent) {
                        parts.unshift(current.name);
                        current = current.parent;
                    }
                    return parts.join('/');
                },
                clear() {
                    this._pathCache.clear();
                }
            },
            Component: {
                _pathCache: new Map(),
                clear() {
                    this._pathCache.clear();
                }
            }
        };

        // Load modules using asset:// protocol - matching CLI's module list
        const MODULES = [
            'base',
            'gfx-webgl2',
            'legacy-pipeline',
            '2d',
            'ui',
            '3d',
            'primitive',
            'graphics',
            'geometry-renderer',
            'animation',
            'tween',
            'rich-text',
            'mask'
        ];

        async function loadModules() {
            showStatus('Loading modules...');

            for (const module of MODULES) {
                try {
                    showStatus(`Loading ${module}...`);
                    // Use asset:// custom protocol to load from local filesystem
                    const imported = await import(`asset://localhost/ccesengine/${module}.js`);

                    if (module === 'base') {
                        cc = imported.cclegacy;
                        window.cc = cc;
                        game = cc.game;
                        director = cc.director;
                    } else {
                        // Merge module exports into cc
                        for (const [key, value] of Object.entries(imported)) {
                            if (key.startsWith('_') || key === 'default' || key === 'cclegacy') continue;
                            if (typeof value === 'function' || (typeof value === 'object' && value !== null)) {
                                if (!(key in cc)) {
                                    cc[key] = value;
                                }
                            }
                        }
                    }
                } catch (error) {
                    throw new Error(`Failed to load module ${module}: ${error.message}`);
                }
            }
        }

        /**
         * @zh 等待内置 effects 数据注入
         * @en Wait for builtin effects data injection
         */
        async function waitForBuiltinEffects(timeoutMs = 5000) {
            showStatus('Waiting for builtin effects...');
            const startTime = Date.now();

            return new Promise((resolve) => {
                const check = () => {
                    if (window.__BUILTIN_EFFECTS__) {
                        resolve(window.__BUILTIN_EFFECTS__);
                    } else if (Date.now() - startTime > timeoutMs) {
                        console.warn('[ccesengine] Timeout waiting for builtin effects, proceeding without them');
                        resolve(null);
                    } else {
                        requestAnimationFrame(check);
                    }
                };
                check();
            });
        }

        // Store registered effects for later material creation
        let registeredGraphicsEffect = null;

        /**
         * @zh 在 game.init() 之前预注册 effects
         * @en Pre-register effects before game.init()
         *
         * 这确保了当渲染管线激活并调用 initGeometryRendererMaterials() 时
         * effects 已经可用。
         *
         * This ensures effects are available when render pipeline activates
         * and calls initGeometryRendererMaterials().
         */
        // Pass parameters mapping (matching CLI's offline-mappings.js passParams)
        // All keys are UPPERCASE, input values are converted to uppercase before lookup
        const PASS_PARAMS = {
            // blend operation
            ADD: 0, SUB: 1, REV_SUB: 2, MIN: 3, MAX: 4,
            // blend factor
            ZERO: 0, ONE: 1, SRC_ALPHA: 2, DST_ALPHA: 3,
            ONE_MINUS_SRC_ALPHA: 4, ONE_MINUS_DST_ALPHA: 5,
            SRC_COLOR: 6, DST_COLOR: 7, ONE_MINUS_SRC_COLOR: 8,
            ONE_MINUS_DST_COLOR: 9, SRC_ALPHA_SATURATE: 10,
            CONSTANT_COLOR: 11, ONE_MINUS_CONSTANT_COLOR: 12,
            CONSTANT_ALPHA: 13, ONE_MINUS_CONSTANT_ALPHA: 14,
            // stencil operation
            KEEP: 1, REPLACE: 2, INCR: 3, DECR: 4, INVERT: 5, INCR_WRAP: 6, DECR_WRAP: 7,
            // comparison function
            NEVER: 0, LESS: 1, EQUAL: 2, LESS_EQUAL: 3, GREATER: 4,
            NOT_EQUAL: 5, GREATER_EQUAL: 6, ALWAYS: 7,
            // cull mode
            FRONT: 1, BACK: 2,
            // shade mode
            GOURAND: 0, FLAT: 1,
            // polygon mode
            FILL: 0, POINT: 1, LINE: 2,
            // color mask
            NONE: 0, R: 1, G: 2, B: 4, A: 8, ALL: 15,
            // boolean
            TRUE: true, FALSE: false
        };

        // Recursive map function matching CLI's generalMap
        function generalMap(obj) {
            for (const key in obj) {
                const prop = obj[key];
                if (typeof prop === 'string') {
                    let num = parseInt(prop);
                    if (isNaN(num)) {
                        num = PASS_PARAMS[prop.toUpperCase()];
                    }
                    if (num !== undefined) {
                        obj[key] = num;
                    }
                } else if (Array.isArray(prop)) {
                    if (!prop.length) continue;
                    if (typeof prop[0] === 'object') {
                        prop.forEach(generalMap);
                    } else if (typeof prop[0] === 'string') {
                        generalMap(prop);
                    } else if (typeof prop[0] === 'number' && prop.length >= 3) {
                        // color array [r,g,b,a] -> packed RGBA
                        obj[key] = (((prop[0] * 255) << 24) | ((prop[1] * 255) << 16) |
                                   ((prop[2] * 255) << 8) | ((prop[3] || 1) * 255)) >>> 0;
                    }
                } else if (typeof prop === 'object' && prop !== null) {
                    generalMap(prop);
                }
            }
            return obj;
        }

        // Map depthStencilState matching CLI's mapDSS
        function mapDSS(dss) {
            for (const key of Object.keys(dss)) {
                if (!key.startsWith('stencil')) continue;
                if (!key.endsWith('Front') && !key.endsWith('Back')) {
                    dss[key + 'Front'] = dss[key + 'Back'] = dss[key];
                    delete dss[key];
                }
            }
            return generalMap(dss);
        }

        function convertPassStates(pass) {
            if (!pass) return;

            // Process depthStencilState with mapDSS and ensure defaults
            if (pass.depthStencilState) {
                const dss = pass.depthStencilState;
                // Set default values for missing or null properties (JSON may serialize as null)
                if (dss.depthFunc == null) dss.depthFunc = 'LESS';
                if (dss.stencilFuncFront == null) dss.stencilFuncFront = 'ALWAYS';
                if (dss.stencilFuncBack == null) dss.stencilFuncBack = 'ALWAYS';
                if (dss.stencilReadMaskFront == null) dss.stencilReadMaskFront = 0xffff;
                if (dss.stencilReadMaskBack == null) dss.stencilReadMaskBack = 0xffff;
                if (dss.stencilWriteMaskFront == null) dss.stencilWriteMaskFront = 0xffff;
                if (dss.stencilWriteMaskBack == null) dss.stencilWriteMaskBack = 0xffff;
                if (dss.stencilFailOpFront == null) dss.stencilFailOpFront = 'KEEP';
                if (dss.stencilFailOpBack == null) dss.stencilFailOpBack = 'KEEP';
                if (dss.stencilZFailOpFront == null) dss.stencilZFailOpFront = 'KEEP';
                if (dss.stencilZFailOpBack == null) dss.stencilZFailOpBack = 'KEEP';
                if (dss.stencilPassOpFront == null) dss.stencilPassOpFront = 'KEEP';
                if (dss.stencilPassOpBack == null) dss.stencilPassOpBack = 'KEEP';
                if (dss.stencilRefFront == null) dss.stencilRefFront = 1;
                if (dss.stencilRefBack == null) dss.stencilRefBack = 1;
                pass.depthStencilState = mapDSS(dss);
            }

            // Ensure blendState has proper defaults
            if (pass.blendState) {
                if (!pass.blendState.blendColor) {
                    pass.blendState.blendColor = { x: 0, y: 0, z: 0, w: 0 };
                }
                // Ensure blend targets have defaults
                if (pass.blendState.targets) {
                    for (const target of pass.blendState.targets) {
                        if (target.blendEq == null) target.blendEq = 'ADD';
                        if (target.blendAlphaEq == null) target.blendAlphaEq = 'ADD';
                        if (target.blendSrc == null) target.blendSrc = 'ONE';
                        if (target.blendDst == null) target.blendDst = 'ZERO';
                        if (target.blendSrcAlpha == null) target.blendSrcAlpha = 'ONE';
                        if (target.blendDstAlpha == null) target.blendDstAlpha = 'ZERO';
                        if (target.blendColorMask == null) target.blendColorMask = 'ALL';
                    }
                }
            }

            // generalMap handles all other properties recursively
            generalMap(pass);
        }

        function preRegisterEffects(effectsData) {
            if (!effectsData || !Array.isArray(effectsData)) {
                console.warn('[ccesengine] No effects data to pre-register');
                return;
            }

            showStatus('Pre-registering effects...');

            // Debug: List all effect names being registered
            console.log('[ccesengine] Effects to register:', effectsData.map(e => e.name).join(', '));

            const EffectAsset = cc.EffectAsset;
            const programLib = cc.programLib;

            if (!EffectAsset) {
                console.warn('[ccesengine] EffectAsset not available for pre-registration');
                return;
            }

            // Check if geometry-renderer effect is in the data
            const hasGeometryRenderer = effectsData.some(e =>
                e.name === 'internal/builtin-geometry-renderer' ||
                e.name === 'builtin-geometry-renderer'
            );
            console.log('[ccesengine] Has builtin-geometry-renderer effect:', hasGeometryRenderer);

            for (const effectData of effectsData) {
                try {
                    // Create EffectAsset instance
                    const effect = new EffectAsset();
                    effect._name = effectData.name;
                    effect.name = effectData.name;
                    effect._uuid = `builtin-effect-${effectData.name}`;

                    // Set techniques and shaders from compiled data
                    effect.techniques = effectData.techniques || [];
                    effect.shaders = effectData.shaders || [];
                    effect.combinations = effectData.combinations || [];

                    // Ensure each technique pass has required fields and convert enums
                    for (const tech of effect.techniques) {
                        for (const pass of tech.passes || []) {
                            if (pass.propertyIndex === undefined) {
                                pass.propertyIndex = 0;
                            }
                            if (!pass.embeddedMacros) {
                                pass.embeddedMacros = {};
                            }
                            // Initialize default states if not present
                            if (!pass.depthStencilState) {
                                pass.depthStencilState = {
                                    depthTest: true,
                                    depthWrite: true
                                };
                            }
                            if (!pass.rasterizerState) {
                                pass.rasterizerState = {
                                    cullMode: 2 // BACK
                                };
                            }
                            if (!pass.blendState) {
                                pass.blendState = {
                                    targets: [{}],
                                    blendColor: { x: 0, y: 0, z: 0, w: 0 }
                                };
                            }
                            // Convert string enum values to numbers
                            convertPassStates(pass);
                        }
                    }

                    // Register with programLib (shader compilation)
                    if (programLib?.register) {
                        programLib.register(effect);
                    }

                    // Call onLoaded if available
                    if (effect.onLoaded) {
                        effect.onLoaded();
                    }

                    // Register to EffectAsset static map - CRITICAL for Material.initialize()
                    if (EffectAsset.register) {
                        EffectAsset.register(effect);
                    }

                    // Store graphics effect for later material creation
                    if (effectData.name === 'internal/builtin-graphics' || effectData.name === 'builtin-graphics') {
                        registeredGraphicsEffect = effect;
                    }

                    console.log(`[ccesengine] Pre-registered effect: ${effectData.name}, techniques: ${effect.techniques.length}, shaders: ${effect.shaders.length}`);
                } catch (error) {
                    console.error(`[ccesengine] Failed to pre-register effect ${effectData.name}:`, error);
                }
            }

            console.log(`[ccesengine] Pre-registered ${effectsData.length} effects`);

            // Debug: List all registered effects
            if (EffectAsset.getAll) {
                const allEffects = EffectAsset.getAll();
                console.log('[ccesengine] All registered effects after preRegister:', Object.keys(allEffects).join(', '));
            }
        }

        /**
         * @zh 在 game.init() 和 run() 之后完成 effects 注册
         * @en Finalize effects registration after game.init() and run()
         *
         * 此时渲染管线已经激活，可以安全地创建材质。
         * At this point render pipeline is active, safe to create materials.
         */
        function finalizeEffectsRegistration() {
            // Create graphics material if effect was registered
            if (registeredGraphicsEffect) {
                createGraphicsMaterial(registeredGraphicsEffect);
            }
        }

        /**
         * @zh 注册编译好的 effects 到引擎（用于向后兼容）
         * @en Register compiled effects to engine (for backwards compatibility)
         * @deprecated 使用 preRegisterEffects + finalizeEffectsRegistration 代替
         */
        function registerBuiltinEffects(effectsData) {
            preRegisterEffects(effectsData);

            // If pipeline is already active, reinitialize geometry renderer materials
            try {
                const pipelineSceneData = director?.root?.pipeline?.pipelineSceneData;
                if (pipelineSceneData?.initGeometryRendererMaterials) {
                    pipelineSceneData.initGeometryRendererMaterials();
                }
            } catch (geoMatError) {
                // Silently ignore if not available
            }

            finalizeEffectsRegistration();
        }

        /**
         * @zh 创建 Graphics 组件所需的材质
         * @en Create material required by Graphics component
         */
        function createGraphicsMaterial(effect) {
            try {
                const Material = cc.Material;
                const builtinResMgr = cc.builtinResMgr;

                if (!Material || !builtinResMgr || !effect) return;

                // Create material from effect
                const material = new Material();
                material._uuid = 'ui-graphics-material';
                material._name = 'ui-graphics-material';

                try {
                    material.initialize({ effectAsset: effect });
                } catch (initError) {
                    // Try alternative initialization
                    material.initialize({ effectAsset: effect, technique: 0 });
                }

                // Register if material has passes
                if (material.passes?.length > 0 && builtinResMgr.addAsset) {
                    builtinResMgr.addAsset('ui-graphics-material', material);
                }
            } catch (error) {
                console.error('[ccesengine] Failed to create graphics material:', error);
            }
        }

        // Flag to track if game needs re-initialization with project config
        let gameInitializedWithProject = false;
        let pendingProjectConfig = null;

        /**
         * @zh 初始化游戏引擎（模仿 CLI 的 Engine.initEngine）
         * @en Initialize game engine (mimicking CLI's Engine.initEngine)
         */
        async function initGame() {
            showStatus('Initializing game...');

            // Set up EditorExtends globally (like CLI does)
            window.EditorExtends = EditorExtends;

            try {
                // Build init config matching CLI's configuration
                const initConfig = {
                    debugMode: cc.debug?.DebugMode?.WARN || 1,
                    showFPS: false,
                    frameRate: 60,
                    overrideSettings: {
                        engine: {
                            builtinAssets: null,  // 禁用内置资源加载，使用预注册的 effects
                            macros: {
                                ENABLE_TILEDMAP_CULLING: true,
                                TOUCH_TIMEOUT: 5000,
                                ENABLE_TRANSPARENT_CANVAS: false,
                                ENABLE_WEBGL_ANTIALIAS: true,
                                CLEANUP_IMAGE_CACHE: false,
                                ENABLE_MULTI_TOUCH: true,
                                MAX_LABEL_CANVAS_POOL_SIZE: 20,
                            },
                        },
                        profiling: {
                            showFPS: false,
                        },
                        screen: {
                            frameRate: 60,
                            exactFitScreen: true,
                        },
                        rendering: {
                            renderMode: 2, // WebGL
                            customPipeline: false,
                        },
                        physics: {
                            enabled: false, // Disable physics in editor mode
                        },
                    },
                    exactFitScreen: true,
                };

                if (pendingProjectConfig && pendingProjectConfig.serverUrl) {
                    const libraryUrl = pendingProjectConfig.serverUrl + '/library';
                    projectLibraryUrl = libraryUrl;
                    initConfig.overrideSettings.assets = {
                        importBase: libraryUrl,
                        nativeBase: libraryUrl,
                        server: libraryUrl,
                        remoteBundles: [],
                        preloadBundles: [],
                    };
                    console.log('[ccesengine] Assets config:', libraryUrl);
                    gameInitializedWithProject = true;
                }

                // Set up timeout for init
                const initPromise = game.init(initConfig);

                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('game.init() timeout after 10s')), 10000);
                });

                await Promise.race([initPromise, timeoutPromise]);
                console.log('[ccesengine] game.init() completed');
            } catch (initError) {
                console.error('[ccesengine] game.init() failed:', initError);
                throw initError;
            }
        }

        async function runGame() {
            showStatus('Starting game...');

            try {
                game.run();
            } catch (runError) {
                console.error('[ccesengine] game.run() error:', runError);
                throw runError;
            }

            // Wait for director.root to be ready (no timeout - wait indefinitely)
            await new Promise((resolve) => {
                let checkCount = 0;
                const check = () => {
                    checkCount++;
                    if (cc.director?.root) {
                        director = cc.director;
                        console.log('[ccesengine] Engine ready after', checkCount, 'checks');
                        resolve();
                    } else {
                        if (checkCount % 60 === 0) {
                            console.log('[ccesengine] Waiting for engine... cc.director:', !!cc.director, 'root:', !!cc.director?.root);
                        }
                        requestAnimationFrame(check);
                    }
                };
                requestAnimationFrame(check);
            });

            // Patch the shader compilation to filter reserved GLSL macros
            patchShaderCompilation();

            // Patch bundle loading to handle internal bundle
            patchBundleLoading();
        }

        /**
         * @zh 修补着色器编译以过滤保留的 GLSL 宏
         * @en Patch shader compilation to filter reserved GLSL macros
         */
        function patchShaderCompilation() {
            const device = director?.root?.device || cc.gfx?.deviceManager?.gfxDevice;
            if (!device) return;

            // Reserved GLSL macros that cannot be redefined
            const reservedMacros = [
                '__VERSION__',
                'GL_ES',
                'GL_OES_standard_derivatives',
                'GL_EXT_draw_buffers',
                'GL_EXT_frag_depth',
                'GL_EXT_shader_texture_lod',
            ];

            // Create a regex to match and remove these defines
            const reservedDefineRegex = new RegExp(
                `^\\s*#define\\s+(${reservedMacros.join('|')})\\s+.*$`,
                'gm'
            );

            // Try to patch createShader method
            const originalCreateShader = device.createShader?.bind(device);
            if (originalCreateShader) {
                device.createShader = function(shaderInfo) {
                    // Filter reserved macros from vertex and fragment shaders
                    const filteredInfo = { ...shaderInfo };

                    if (filteredInfo.stages) {
                        filteredInfo.stages = filteredInfo.stages.map(stage => {
                            if (stage.source && typeof stage.source === 'string') {
                                const filteredSource = stage.source.replace(reservedDefineRegex, '// [REMOVED RESERVED MACRO]');
                                return { ...stage, source: filteredSource };
                            }
                            return stage;
                        });
                    }

                    return originalCreateShader(filteredInfo);
                };
            }

            // Also try to patch the programLib's getGLSLSource if available
            const programLib = cc.programLib;
            if (programLib) {
                const originalGetGLSLSource = programLib.getGLSLSource?.bind(programLib);
                if (originalGetGLSLSource) {
                    programLib.getGLSLSource = function(...args) {
                        const result = originalGetGLSLSource(...args);
                        if (result && typeof result === 'object') {
                            if (result.vert) {
                                result.vert = result.vert.replace(reservedDefineRegex, '// [REMOVED RESERVED MACRO]');
                            }
                            if (result.frag) {
                                result.frag = result.frag.replace(reservedDefineRegex, '// [REMOVED RESERVED MACRO]');
                            }
                        }
                        return result;
                    };
                }
            }
        }

        /**
         * @zh 拦截 bundle 加载，处理内置 bundle
         * @en Patch bundle loading to handle internal bundle
         */
        function patchBundleLoading() {
            const assetManager = cc.assetManager;
            if (!assetManager) return;

            const originalLoadBundle = assetManager.loadBundle?.bind(assetManager);
            if (!originalLoadBundle) return;

            // Create mock internal bundle
            const mockInternalBundle = {
                name: 'internal',
                deps: [],
                _isLoaded: true,
                getInfoWithPath: () => null,
                get: (path, type, callback) => {
                    if (typeof type === 'function') callback = type;
                    if (callback) callback(null, null);
                    return null;
                },
                load: (path, type, progress, callback) => {
                    if (typeof type === 'function') {
                        callback = type;
                    } else if (typeof progress === 'function') {
                        callback = progress;
                    }
                    if (callback) callback(null, null);
                },
                loadDir: (path, type, progress, callback) => {
                    if (typeof type === 'function') {
                        callback = type;
                    } else if (typeof progress === 'function') {
                        callback = progress;
                    }
                    if (callback) callback(null, []);
                },
                preload: (path, type, progress, callback) => {
                    if (typeof type === 'function') {
                        callback = type;
                    } else if (typeof progress === 'function') {
                        callback = progress;
                    }
                    if (callback) callback(null);
                },
                release: () => {},
                releaseAll: () => {},
            };

            // Store in bundles cache
            if (assetManager.bundles) {
                assetManager.bundles.add('internal', mockInternalBundle);
            }

            assetManager.loadBundle = function(nameOrUrl, options, onComplete) {
                // Normalize arguments
                if (typeof options === 'function') {
                    onComplete = options;
                    options = null;
                }

                // Intercept internal bundle loading
                if (nameOrUrl === 'internal' || nameOrUrl === 'INTERNAL') {
                    console.log('[ccesengine] Intercepted internal bundle load, using mock');
                    if (onComplete) {
                        setTimeout(() => onComplete(null, mockInternalBundle), 0);
                    }
                    return;
                }

                // Pass through to original for other bundles
                return originalLoadBundle(nameOrUrl, options, onComplete);
            };

            console.log('[ccesengine] Bundle loading patched for internal bundle');
        }

        function createDefaultScene() {
            showStatus('Creating scene...');

            // Create empty scene
            scene = new cc.Scene('EditorScene');
            scene._inited = true;

            // Create camera node
            const cameraNode = new cc.Node('Main Camera');
            scene.addChild(cameraNode);

            // Add camera component
            const Camera = cc.Camera;
            if (Camera) {
                const camera = cameraNode.addComponent(Camera);
                camera.clearFlags = cc.Camera?.ClearFlag?.SOLID_COLOR ?? 7;
                // Use dark gray background (editor style)
                camera.clearColor = cc.color('#2d2d2d');

                // Cache the camera component
                mainCameraComp = camera;

                // Setup camera based on view mode
                setupCameraForViewMode(cameraNode, camera);
            }

            // Run scene
            director.runSceneImmediate(scene);
        }

        // Camera control state - Free look mode (like FPS)
        let cameraPos = { x: 15, y: 10, z: 15 };  // Camera world position
        let cameraYaw = -135;     // Horizontal angle (degrees) - looking toward origin
        let cameraPitch = -20;    // Vertical angle (degrees) - looking down slightly
        let cameraTarget = { x: 0, y: 0, z: 0 };  // For 2D mode and panning reference
        let orthoSize = 10;       // Orthographic size

        /**
         * @zh 根据视图模式设置相机（自由视角模式）
         * @en Setup camera based on view mode (free look mode)
         *
         * Cocos Creator 3.x ProjectionType:
         * - ORTHO = 0
         * - PERSPECTIVE = 1
         *
         * In 3D mode: Camera uses direct position + euler rotation (free look)
         * In 2D mode: Camera uses orthographic projection looking at XY plane
         */
        function setupCameraForViewMode(cameraNode, camera) {
            if (!cameraNode || !camera) return;

            // Get enum values from Cocos (with fallback)
            const ORTHO = cc.Camera?.ProjectionType?.ORTHO ?? 0;
            const PERSPECTIVE = cc.Camera?.ProjectionType?.PERSPECTIVE ?? 1;

            if (viewMode === '2d') {
                // 2D mode: Orthographic camera looking at XY plane
                cameraNode.setPosition(cameraTarget.x, cameraTarget.y, 100);
                cameraNode.setRotationFromEuler(0, 0, 0);
                camera.projection = ORTHO;
                camera.orthoHeight = orthoSize;
            } else {
                // 3D mode: Free look camera using direct position and euler rotation
                cameraNode.setPosition(cameraPos.x, cameraPos.y, cameraPos.z);

                // Set rotation from euler angles (pitch = X, yaw = Y)
                // Note: In Cocos, rotation order is ZYX
                cameraNode.setRotationFromEuler(cameraPitch, cameraYaw, 0);

                camera.projection = PERSPECTIVE;
                camera.fov = 60;
            }
            camera.near = 0.1;
            camera.far = 100000; // Extended far plane for grid visibility at large distances

            console.log('[Camera] Setup:', viewMode, 'projection:', camera.projection, '(ORTHO=' + ORTHO + ', PERSPECTIVE=' + PERSPECTIVE + ')', 'pos:', cameraNode.position, 'rot:', cameraPitch, cameraYaw);
        }

        /**
         * @zh 计算相机前进方向
         * @en Calculate camera forward direction
         */
        function getCameraForward() {
            const pitchRad = cameraPitch * Math.PI / 180;
            const yawRad = cameraYaw * Math.PI / 180;
            return {
                x: -Math.sin(yawRad) * Math.cos(pitchRad),
                y: Math.sin(pitchRad),
                z: -Math.cos(yawRad) * Math.cos(pitchRad)
            };
        }

        /**
         * @zh 计算相机右方向
         * @en Calculate camera right direction
         */
        function getCameraRight() {
            const yawRad = cameraYaw * Math.PI / 180;
            return {
                x: Math.cos(yawRad),
                y: 0,
                z: -Math.sin(yawRad)
            };
        }

        /**
         * @zh 更新相机视图
         * @en Update camera view
         */
        function updateCameraView() {
            if (mainCameraComp) {
                setupCameraForViewMode(mainCameraComp.node, mainCameraComp);
            }
        }

        /**
         * @zh 切换视图模式
         * @en Toggle view mode
         */
        function setViewMode(mode) {
            if (mode !== '2d' && mode !== '3d') return;
            if (mode === viewMode) return;

            viewMode = mode;

            // Update camera
            if (mainCameraComp) {
                setupCameraForViewMode(mainCameraComp.node, mainCameraComp);
            } else {
                // Try to find camera if not cached
                const cameraNode = scene?.getChildByName('Main Camera');
                if (cameraNode) {
                    const cam = cameraNode.getComponent(cc.Camera);
                    if (cam) {
                        mainCameraComp = cam;
                        setupCameraForViewMode(cameraNode, cam);
                    }
                }
            }

            rpc?.emitViewModeChanged(viewMode);
        }

        function handleResize() {
            const canvas = document.getElementById('GameCanvas');
            const width = window.innerWidth;
            const height = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;

            // Update canvas physical and CSS size
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;

            // Update engine root
            if (director?.root) {
                director.root.resize(canvas.width, canvas.height);
            }

            // Update main camera based on view mode
            if (mainCameraComp) {
                if (viewMode === '2d') {
                    // Use the current orthoSize (which may have been set by syncSceneFromData for UI scenes)
                    mainCameraComp.orthoHeight = orthoSize;
                }
                // 3D perspective mode automatically adjusts with aspect ratio
            }
        }

        function registerRpcMethods() {
            if (!rpc) return;

            const { Methods } = window.ViewportRpc;

            // Viewport control
            rpc.registerMethod(Methods.RESIZE, () => {
                handleResize();
                return null;
            });

            rpc.registerMethod(Methods.SET_VIEW_MODE, (params) => {
                const mode = params?.mode || '3d';
                setViewMode(mode);
                return { viewMode };
            });

            rpc.registerMethod(Methods.GET_STATE, () => {
                return window.esengine?.getState() ?? {
                    isPlaying: false,
                    isPaused: false,
                    isEditMode: true,
                    viewMode
                };
            });

            // Scene operations
            rpc.registerMethod(Methods.CREATE_NODE, (params) => {
                if (!scene) throw new Error('No scene');
                const node = new cc.Node(params?.name || 'New Node');
                if (params?.position) {
                    node.setPosition(params.position.x || 0, params.position.y || 0, params.position.z || 0);
                }
                scene.addChild(node);
                return { uuid: node.uuid };
            });

            rpc.registerMethod(Methods.GET_SCENE_INFO, () => {
                if (!scene) throw new Error('No scene');
                const nodes = [];
                scene.children.forEach(child => {
                    nodes.push({
                        uuid: child.uuid,
                        name: child.name,
                        position: {
                            x: child.position.x,
                            y: child.position.y,
                            z: child.position.z,
                        }
                    });
                });
                return { sceneName: scene.name, nodes };
            });

            rpc.registerMethod(Methods.SELECT_NODE, (params) => {
                // TODO: Implement node selection
                console.log('[RPC] selectNode:', params?.uuid);
                return null;
            });

            // Playback control
            rpc.registerMethod(Methods.PLAY, () => {
                window.esengine?.play();
                return null;
            });

            rpc.registerMethod(Methods.PAUSE, () => {
                window.esengine?.pause();
                return null;
            });

            rpc.registerMethod(Methods.STOP, () => {
                window.esengine?.stop();
                return null;
            });

            rpc.registerMethod(Methods.SET_EDIT_MODE, (params) => {
                window.esengine?.setEditMode(params?.editMode ?? true);
                return null;
            });

            // Camera control
            rpc.registerMethod(Methods.RESET_CAMERA, () => {
                cameraPos = { x: 15, y: 10, z: 15 };
                cameraYaw = -135;
                cameraPitch = -20;
                cameraTarget = { x: 0, y: 0, z: 0 };
                orthoSize = 10;
                updateCameraView();
                return null;
            });

            rpc.registerMethod(Methods.FOCUS_SELECTED, () => {
                // TODO: Focus on selected node
                console.log('[RPC] focusSelected');
                return null;
            });

            console.log('[Viewport] RPC methods registered');
        }

        // Register methods immediately
        registerRpcMethods();

        // Main initialization
        async function main() {
            try {
                await loadModules();

                // IMPORTANT: Wait for and register builtin effects BEFORE game.init()
                // This ensures effects are available when render pipeline activates
                // and calls initGeometryRendererMaterials()
                showStatus('Waiting for builtin effects...');
                const effectsData = await waitForBuiltinEffects(3000);
                console.log('[ccesengine] Received effects data:', effectsData ? `${Array.isArray(effectsData) ? effectsData.length : 'not array'} effects` : 'null');
                if (effectsData) {
                    // Pre-register effects before game.init()
                    preRegisterEffects(effectsData);
                } else {
                    console.warn('[ccesengine] No builtin effects received, some features may not work');
                    console.warn('[ccesengine] Grid rendering will NOT work without builtin-geometry-renderer effect');
                }

                await initGame();
                await runGame();

                // Post-initialization: ensure materials are properly compiled
                finalizeEffectsRegistration();

                createDefaultScene();

                // Setup 3D grid rendering using GeometryRenderer
                setupGridRendering();

                // Setup resize handler
                window.addEventListener('resize', handleResize);
                handleResize();

                // Hide loading
                loadingEl.style.display = 'none';

                console.log('[ccesengine] Initialization complete');
                rpc?.emitReady('1.0.0');

            } catch (error) {
                const errorMsg = error?.message || String(error);
                const errorStack = error?.stack || '';
                console.error('Initialization failed:', errorMsg, errorStack);
                showError(errorMsg);
            }
        }

        // Store geometry renderer reference
        let geometryRenderer = null;
        let mainCameraComp = null;

        /**
         * @zh 初始化 GeometryRenderer 用于 3D 网格绘制
         * @en Initialize GeometryRenderer for 3D grid drawing
         *
         * Camera 组件有一个 .camera 属性指向内部渲染 camera，
         * initGeometryRenderer 方法在内部 camera 上，不是组件上。
         *
         * The Camera component has a .camera property pointing to the internal render camera.
         * The initGeometryRenderer method is on the internal camera, not the component.
         */
        function initGeometryRenderer() {
            // Get the main camera from scene
            const cameraNode = scene?.getChildByName('Main Camera');
            if (!cameraNode) {
                console.log('[ccesengine] initGeometryRenderer: cameraNode not found');
                return false;
            }

            mainCameraComp = cameraNode.getComponent(cc.Camera);
            if (!mainCameraComp) {
                console.log('[ccesengine] initGeometryRenderer: Camera component not found');
                return false;
            }

            // Get internal render camera from Camera component
            const internalCamera = mainCameraComp.camera;
            if (!internalCamera) {
                console.log('[ccesengine] initGeometryRenderer: internal camera not found, _camera:', !!mainCameraComp._camera);
                return false;
            }

            // Initialize geometry renderer on internal camera
            if (typeof internalCamera.initGeometryRenderer === 'function') {
                try {
                    internalCamera.initGeometryRenderer();
                    geometryRenderer = internalCamera.geometryRenderer;
                    console.log('[ccesengine] initGeometryRenderer: success, geometryRenderer:', !!geometryRenderer);
                    return !!geometryRenderer;
                } catch (e) {
                    console.error('[ccesengine] initGeometryRenderer error:', e);
                    return false;
                }
            } else {
                console.log('[ccesengine] initGeometryRenderer: method not available on internal camera');
            }
            return false;
        }

        /**
         * @zh 使用 GeometryRenderer 绘制无限多层网格
         * @en Draw infinite multi-layered grid using GeometryRenderer
         *
         * @zh 网格特性：
         * - 多层网格：小网格 (1 单位)、中网格 (10 单位)、大网格 (100 单位)
         * - 线条根据相机距离淡入淡出
         * - 网格范围根据相机距离动态调整
         * - 限制最大线条数量以保持性能
         *
         * @en Grid features:
         * - Multiple layers: small (1 unit), medium (10 units), large (100 units)
         * - Lines fade based on camera distance
         * - Grid extent scales dynamically with camera distance
         * - Max line count limited for performance
         */
        let drawGridCalled = false;
        let drawGridCallCount = 0;
        const MAX_LINES_PER_AXIS = 150; // Increased for better grid coverage

        function drawGrid() {
            if (!geometryRenderer) return;
            if (!gridVisible) return;
            drawGridCallCount++;
            if (!drawGridCalled) {
                console.log('[ccesengine] drawGrid first call, viewMode:', viewMode, 'cameraPos:', JSON.stringify(cameraPos));
                drawGridCalled = true;
            }
            // Log every 60 frames (about every second)
            if (drawGridCallCount % 60 === 0) {
                console.log('[ccesengine] drawGrid frame', drawGridCallCount, 'geometryRenderer.empty:', geometryRenderer.empty?.());
            }

            const Vec3 = cc.Vec3;
            const Color = cc.Color;
            const v0 = new Vec3();
            const v1 = new Vec3();

            // Calculate effective camera distance for grid scaling
            const cameraHeight = viewMode === '2d'
                ? orthoSize * 2
                : Math.max(Math.abs(cameraPos.y), 2);

            // Grid center: use cameraTarget for 2D, use camera XZ position for 3D
            const gridCenter = viewMode === '2d'
                ? { x: cameraTarget.x, y: cameraTarget.y, z: 0 }
                : { x: cameraPos.x, y: 0, z: cameraPos.z };

            // Calculate visible extent based on camera height and FOV
            // Use larger multiplier for closer views to show more grid
            // Minimum extent of 500 units to ensure grid is always visible at close range
            const extentMultiplier = cameraHeight < 10 ? 8 : (cameraHeight < 50 ? 6 : (cameraHeight < 200 ? 4 : 3));
            const visibleExtent = Math.max(500, cameraHeight * extentMultiplier);

            // Grid levels with smooth transitions
            // Each level has: spacing (world units), alpha (0-255), isMajor (thicker line)
            const gridLevels = [];

            // Sub-fine grid (0.1 unit) - visible when very close
            if (cameraHeight < 5) {
                const fadeStart = 0.5, fadeEnd = 5;
                const t = Math.max(0, Math.min(1, (fadeEnd - cameraHeight) / (fadeEnd - fadeStart)));
                const alpha = Math.floor(t * 45);
                if (alpha > 5) {
                    gridLevels.push({ spacing: 0.1, alpha, isMajor: false });
                }
            }

            // Fine grid (1 unit) - visible when close, extended range
            if (cameraHeight < 80) {
                const fadeStart = 5, fadeEnd = 80;
                const t = Math.max(0, Math.min(1, (fadeEnd - cameraHeight) / (fadeEnd - fadeStart)));
                // Use smoother fade curve and higher base alpha
                const alpha = Math.floor(25 + t * 55); // Base 25 alpha even at edge
                if (alpha > 10) {
                    gridLevels.push({ spacing: 1, alpha, isMajor: cameraHeight < 15 });
                }
            }

            // Medium grid (10 units) - always visible when reasonably close
            if (cameraHeight < 800) {
                const fadeStart = 10, fadeEnd = 800;
                const t = Math.max(0, Math.min(1, (fadeEnd - cameraHeight) / (fadeEnd - fadeStart)));
                // Higher base alpha for better visibility
                const alpha = Math.floor(45 + t * 70);
                gridLevels.push({ spacing: 10, alpha: Math.min(alpha, 115), isMajor: cameraHeight > 20 });
            }

            // Large grid (100 units) - always visible
            {
                // Brighter at far distances
                const alpha = cameraHeight > 300 ? 120 : (cameraHeight > 100 ? 100 : (cameraHeight > 30 ? 75 : 50));
                gridLevels.push({ spacing: 100, alpha, isMajor: true });
            }

            // Very large grid (1000 units) - visible earlier for medium-far view
            if (cameraHeight > 30) {
                const fadeStart = 30, fadeEnd = 500;
                const t = Math.min(1, (cameraHeight - fadeStart) / (fadeEnd - fadeStart));
                const alpha = Math.floor(15 + t * 70);
                gridLevels.push({ spacing: 1000, alpha, isMajor: cameraHeight > 200 });
            }

            // Extra large grid (10000 units) - for very far views
            if (cameraHeight > 300) {
                const fadeStart = 300, fadeEnd = 5000;
                const t = Math.min(1, (cameraHeight - fadeStart) / (fadeEnd - fadeStart));
                const alpha = Math.floor(10 + t * 50);
                gridLevels.push({ spacing: 10000, alpha, isMajor: true });
            }

            if (viewMode === '2d') {
                // 2D mode: Draw grid on XY plane (Z=0)
                for (const level of gridLevels) {
                    const { spacing, alpha, isMajor } = level;

                    // Calculate extent ensuring we don't draw too many lines
                    const maxExtent = Math.min(visibleExtent, spacing * MAX_LINES_PER_AXIS / 2);

                    // Snap to grid
                    const startX = Math.floor((gridCenter.x - maxExtent) / spacing) * spacing;
                    const endX = Math.ceil((gridCenter.x + maxExtent) / spacing) * spacing;
                    const startY = Math.floor((gridCenter.y - maxExtent) / spacing) * spacing;
                    const endY = Math.ceil((gridCenter.y + maxExtent) / spacing) * spacing;

                    const gridColor = isMajor
                        ? new Color(90, 90, 90, alpha)
                        : new Color(55, 55, 55, alpha);

                    // Vertical lines (along Y)
                    for (let x = startX; x <= endX; x += spacing) {
                        if (Math.abs(x) < 0.001) continue; // Skip axis
                        v0.set(x, startY, 0);
                        v1.set(x, endY, 0);
                        geometryRenderer.addLine(v0, v1, gridColor, false);
                    }

                    // Horizontal lines (along X)
                    for (let y = startY; y <= endY; y += spacing) {
                        if (Math.abs(y) < 0.001) continue; // Skip axis
                        v0.set(startX, y, 0);
                        v1.set(endX, y, 0);
                        geometryRenderer.addLine(v0, v1, gridColor, false);
                    }
                }

                // Draw axes (always on top)
                const axisExtent = visibleExtent * 1.5;

                // X axis (red)
                v0.set(gridCenter.x - axisExtent, 0, 0);
                v1.set(gridCenter.x + axisExtent, 0, 0);
                geometryRenderer.addLine(v0, v1, new Color(180, 60, 60, 255), false);

                // Y axis (green)
                v0.set(0, gridCenter.y - axisExtent, 0);
                v1.set(0, gridCenter.y + axisExtent, 0);
                geometryRenderer.addLine(v0, v1, new Color(60, 180, 60, 255), false);

            } else {
                // 3D mode: Draw grid on XZ plane (Y=0)
                for (const level of gridLevels) {
                    const { spacing, alpha, isMajor } = level;

                    // Calculate extent ensuring we don't draw too many lines
                    const maxExtent = Math.min(visibleExtent, spacing * MAX_LINES_PER_AXIS / 2);

                    // Snap to grid
                    const startX = Math.floor((gridCenter.x - maxExtent) / spacing) * spacing;
                    const endX = Math.ceil((gridCenter.x + maxExtent) / spacing) * spacing;
                    const startZ = Math.floor((gridCenter.z - maxExtent) / spacing) * spacing;
                    const endZ = Math.ceil((gridCenter.z + maxExtent) / spacing) * spacing;

                    const gridColor = isMajor
                        ? new Color(90, 90, 90, alpha)
                        : new Color(55, 55, 55, alpha);

                    // Lines along Z
                    for (let x = startX; x <= endX; x += spacing) {
                        if (Math.abs(x) < 0.001) continue; // Skip axis
                        v0.set(x, 0, startZ);
                        v1.set(x, 0, endZ);
                        geometryRenderer.addLine(v0, v1, gridColor, false);
                    }

                    // Lines along X
                    for (let z = startZ; z <= endZ; z += spacing) {
                        if (Math.abs(z) < 0.001) continue; // Skip axis
                        v0.set(startX, 0, z);
                        v1.set(endX, 0, z);
                        geometryRenderer.addLine(v0, v1, gridColor, false);
                    }
                }

                // Draw axes (always on top)
                const axisExtent = visibleExtent * 1.5;

                // X axis (red)
                v0.set(gridCenter.x - axisExtent, 0, 0);
                v1.set(gridCenter.x + axisExtent, 0, 0);
                geometryRenderer.addLine(v0, v1, new Color(180, 60, 60, 255), false);

                // Y axis (green) - pointing up
                v0.set(0, 0, 0);
                v1.set(0, Math.max(axisExtent * 0.5, 20), 0);
                geometryRenderer.addLine(v0, v1, new Color(60, 180, 60, 255), false);

                // Z axis (blue)
                v0.set(0, 0, gridCenter.z - axisExtent);
                v1.set(0, 0, gridCenter.z + axisExtent);
                geometryRenderer.addLine(v0, v1, new Color(60, 60, 180, 255), false);
            }

            // Debug: log line count on first few frames
            if (drawGridCallCount <= 3) {
                console.log('[ccesengine] drawGrid: gridLevels:', gridLevels.length, 'visibleExtent:', visibleExtent, 'cameraHeight:', viewMode === '2d' ? orthoSize * 2 : Math.max(Math.abs(cameraPos.y), 2));
            }
        }

        /**
         * @zh 绘制场景节点标记
         * @en Draw scene node markers
         *
         * @zh 在每个节点位置绘制十字标记或小立方体线框
         * @en Draw cross markers or small wireframe cubes at each node position
         */
        function drawNodeMarkers() {
            if (!geometryRenderer) return;
            if (!nodeMarkersVisible) return;
            if (sceneNodes.length === 0) return;

            const Vec3 = cc.Vec3;
            const Color = cc.Color;
            const v0 = new Vec3();
            const v1 = new Vec3();

            // Marker size (in world units) - scale with orthoSize for 2D mode
            const markerSize = viewMode === '2d' ? orthoSize * 0.03 : 0.5;

            for (const nodeInfo of sceneNodes) {
                const pos = nodeInfo.position || { x: 0, y: 0, z: 0 };
                const isSelected = nodeInfo.uuid === selectedNodeUuid;

                // Choose color based on selection state
                const color = isSelected
                    ? new Color(255, 180, 0, 255) // Orange for selected
                    : new Color(100, 180, 255, 180); // Light blue for normal

                if (viewMode === '2d') {
                    // 2D mode: Draw cross on XY plane (Z=0)
                    const x = pos.x;
                    const y = pos.y;
                    const z = 0.01; // Slightly above grid

                    // Horizontal line
                    v0.set(x - markerSize, y, z);
                    v1.set(x + markerSize, y, z);
                    geometryRenderer.addLine(v0, v1, color, false);

                    // Vertical line
                    v0.set(x, y - markerSize, z);
                    v1.set(x, y + markerSize, z);
                    geometryRenderer.addLine(v0, v1, color, false);

                    // Draw box around selected
                    if (isSelected) {
                        const boxSize = markerSize * 1.5;
                        v0.set(x - boxSize, y - boxSize, z);
                        v1.set(x + boxSize, y - boxSize, z);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y - boxSize, z);
                        v1.set(x + boxSize, y + boxSize, z);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y + boxSize, z);
                        v1.set(x - boxSize, y + boxSize, z);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x - boxSize, y + boxSize, z);
                        v1.set(x - boxSize, y - boxSize, z);
                        geometryRenderer.addLine(v0, v1, color, false);
                    }
                } else {
                    // 3D mode: Draw 3D cross at node position
                    const x = pos.x;
                    const y = pos.y;
                    const z = pos.z;

                    // X axis line (red-ish)
                    v0.set(x - markerSize, y, z);
                    v1.set(x + markerSize, y, z);
                    geometryRenderer.addLine(v0, v1, color, false);

                    // Y axis line (up)
                    v0.set(x, y - markerSize, z);
                    v1.set(x, y + markerSize, z);
                    geometryRenderer.addLine(v0, v1, color, false);

                    // Z axis line
                    v0.set(x, y, z - markerSize);
                    v1.set(x, y, z + markerSize);
                    geometryRenderer.addLine(v0, v1, color, false);

                    // Draw wireframe cube for selected node
                    if (isSelected) {
                        const boxSize = markerSize * 1.2;
                        // Bottom face
                        v0.set(x - boxSize, y - boxSize, z - boxSize);
                        v1.set(x + boxSize, y - boxSize, z - boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y - boxSize, z - boxSize);
                        v1.set(x + boxSize, y - boxSize, z + boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y - boxSize, z + boxSize);
                        v1.set(x - boxSize, y - boxSize, z + boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x - boxSize, y - boxSize, z + boxSize);
                        v1.set(x - boxSize, y - boxSize, z - boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);

                        // Top face
                        v0.set(x - boxSize, y + boxSize, z - boxSize);
                        v1.set(x + boxSize, y + boxSize, z - boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y + boxSize, z - boxSize);
                        v1.set(x + boxSize, y + boxSize, z + boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y + boxSize, z + boxSize);
                        v1.set(x - boxSize, y + boxSize, z + boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x - boxSize, y + boxSize, z + boxSize);
                        v1.set(x - boxSize, y + boxSize, z - boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);

                        // Vertical edges
                        v0.set(x - boxSize, y - boxSize, z - boxSize);
                        v1.set(x - boxSize, y + boxSize, z - boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y - boxSize, z - boxSize);
                        v1.set(x + boxSize, y + boxSize, z - boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x + boxSize, y - boxSize, z + boxSize);
                        v1.set(x + boxSize, y + boxSize, z + boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                        v0.set(x - boxSize, y - boxSize, z + boxSize);
                        v1.set(x - boxSize, y + boxSize, z + boxSize);
                        geometryRenderer.addLine(v0, v1, color, false);
                    }
                }
            }
        }

        /**
         * @zh 设置渲染循环中的网格绘制
         * @en Setup grid drawing in render loop
         *
         * 内部 camera 可能需要几帧才能准备好，所以需要重试机制。
         * The internal camera may take a few frames to be ready, so retry is needed.
         *
         * 注意：必须使用 EVENT_BEFORE_UPDATE 而不是 EVENT_BEFORE_DRAW，
         * 因为 addLine() 会调用 updateBuffer，而 updateBuffer 必须在
         * render pass 之外执行。
         *
         * Note: Must use EVENT_BEFORE_UPDATE instead of EVENT_BEFORE_DRAW,
         * because addLine() calls updateBuffer which must be executed
         * outside of render pass.
         */
        function setupGridRendering() {
            let retryCount = 0;
            const maxRetries = 60; // Increase retries

            console.log('[ccesengine] setupGridRendering: starting');

            function tryInit() {
                if (retryCount % 10 === 0) {
                    console.log('[ccesengine] setupGridRendering: attempt', retryCount);
                }

                if (initGeometryRenderer()) {
                    // Use Director event for proper timing with render pipeline
                    // Draw grid and node markers each frame
                    director.on(cc.Director.EVENT_BEFORE_COMMIT, () => {
                        drawGrid();
                        drawNodeMarkers();
                    });
                    console.log('[ccesengine] Grid and marker rendering enabled after', retryCount, 'attempts');
                } else if (retryCount < maxRetries) {
                    retryCount++;
                    requestAnimationFrame(tryInit);
                } else {
                    console.warn('[ccesengine] Failed to initialize GeometryRenderer after', maxRetries, 'attempts');
                    // Print diagnostic info
                    console.log('[ccesengine] Diagnostic: scene:', !!scene, 'director:', !!director);
                    if (scene) {
                        const cam = scene.getChildByName('Main Camera');
                        console.log('[ccesengine] Diagnostic: cameraNode:', !!cam);
                        if (cam) {
                            const comp = cam.getComponent(cc.Camera);
                            console.log('[ccesengine] Diagnostic: cameraComp:', !!comp, 'camera:', !!comp?.camera, '_camera:', !!comp?._camera);
                            if (comp?.camera) {
                                console.log('[ccesengine] Diagnostic: initGeometryRenderer:', typeof comp.camera.initGeometryRenderer);
                            }
                        }
                    }
                }
            }

            tryInit();
        }

        let gridVisible = true;
        let snapEnabled = false;

        // Node markers state
        let nodeMarkersVisible = true;
        let sceneNodes = []; // Track created scene nodes
        let selectedNodeUuid = null;

        // Expose setViewMode to window for Rust IPC
        window.setViewMode = setViewMode;

        /**
         * @zh 设置网格可见性
         * @en Set grid visibility
         */
        window.setGridVisible = function(visible) {
            gridVisible = visible;
            console.log('[ccesengine] Grid visibility:', visible);
        };

        /**
         * @zh 设置吸附启用状态
         * @en Set snap enabled state
         */
        window.setSnapEnabled = function(enabled) {
            snapEnabled = enabled;
            console.log('[ccesengine] Snap enabled:', enabled);
        };

        // Engine state for play/pause/stop
        let isPlaying = false;
        let isPaused = false;
        let isEditMode = true;

        // Asset info cache for URL to UUID conversion
        let assetsInfoCache = null;

        /**
         * @zh 获取资产信息映射
         * @en Fetch assets info mapping
         * @returns {Promise<Object>} 资产路径到UUID的映射
         */
        async function fetchAssetsInfo() {
            if (assetsInfoCache) return assetsInfoCache;
            if (!projectServerUrl) return null;

            try {
                const response = await fetch(`${projectServerUrl}/library/.assets-info.json`);
                if (!response.ok) {
                    console.error('[esengine] Failed to fetch .assets-info.json:', response.status);
                    return null;
                }
                const data = await response.json();
                assetsInfoCache = data;
                console.log('[esengine] Assets info loaded, entries:', Object.keys(data.map || {}).length);
                return data;
            } catch (err) {
                console.error('[esengine] Error fetching .assets-info.json:', err);
                return null;
            }
        }

        /**
         * @zh 将 db:// URL 转换为 UUID
         * @en Convert db:// URL to UUID
         * @param {string} dbUrl - 如 "db://assets/scenes/login.scene"
         * @returns {Promise<string|null>} UUID 或 null
         */
        async function urlToUuid(dbUrl) {
            const assetsInfo = await fetchAssetsInfo();
            if (!assetsInfo || !assetsInfo.map) return null;

            // db://assets/scenes/login.scene -> scenes/login.scene (or scenes\\login.scene on Windows)
            let relativePath = dbUrl;
            if (dbUrl.startsWith('db://assets/')) {
                relativePath = dbUrl.substring('db://assets/'.length);
            } else if (dbUrl.startsWith('db://')) {
                relativePath = dbUrl.substring('db://'.length);
            }

            // Try both forward slash and backslash versions
            const pathVariants = [
                relativePath,
                relativePath.replace(/\//g, '\\'),
                relativePath.replace(/\\/g, '/')
            ];

            for (const path of pathVariants) {
                if (assetsInfo.map[path]) {
                    return assetsInfo.map[path].uuid;
                }
            }

            console.warn('[esengine] URL not found in assets info:', dbUrl, 'tried:', pathVariants);
            return null;
        }

        /**
         * @zh 根据 UUID 获取 library 中的资源路径
         * @en Get library resource path from UUID
         * @param {string} uuid - 资源 UUID
         * @returns {string} library 中的相对路径
         */
        function getLibraryPath(uuid) {
            // UUID 前两位作为目录，完整 UUID 作为文件名
            const prefix = uuid.substring(0, 2);
            return `${prefix}/${uuid}.json`;
        }

        /**
         * @zh 编辑器引擎控制 API
         * @en Editor engine control API
         */
        window.esengine = {
            /**
             * @zh 播放游戏
             * @en Play game
             */
            play: function() {
                if (isPlaying && !isPaused) return;
                isPlaying = true;
                isPaused = false;
                isEditMode = false;
                if (director) director.resume();
                rpc?.emitPlayStateChanged('playing');
            },

            pause: function() {
                if (!isPlaying || isPaused) return;
                isPaused = true;
                if (director) director.pause();
                rpc?.emitPlayStateChanged('paused');
            },

            stop: function() {
                if (!isPlaying) return;
                isPlaying = false;
                isPaused = false;
                isEditMode = true;
                if (director) director.resume();
                rpc?.emitPlayStateChanged('stopped');
            },

            setEditMode: function(editMode) {
                isEditMode = editMode;
                // TODO: Emit editModeChanged event
            },

            /**
             * @zh 获取当前状态
             * @en Get current state
             */
            getState: function() {
                return {
                    isPlaying,
                    isPaused,
                    isEditMode,
                    viewMode
                };
            },

            /**
             * @zh 配置项目资源路径（模仿 CLI 的配置方式）
             * @en Configure project resource paths (mimicking CLI's configuration)
             * @param {Object} config - 配置对象
             * @param {string} config.serverUrl - 资源服务器URL（如 http://127.0.0.1:12345）
             */
            setProjectConfig: async function(config) {
                console.log('[esengine] Setting project config:', config);
                if (config.serverUrl) {
                    projectServerUrl = config.serverUrl;
                    const libraryUrl = config.serverUrl + '/library';
                    projectLibraryUrl = libraryUrl;

                    // Store config for potential engine re-init
                    pendingProjectConfig = config;

                    // Configure assetManager (matching CLI's approach)
                    const assetManager = cc.assetManager;
                    if (assetManager) {
                        // Configure downloader remote server
                        if (assetManager.downloader) {
                            assetManager.downloader.remoteServerAddress = libraryUrl;
                            console.log('[esengine] Downloader remoteServerAddress:', libraryUrl);
                        }

                        if (cc.settings) {
                            cc.settings.overrideSettings('assets', 'server', libraryUrl);
                            cc.settings.overrideSettings('assets', 'importBase', libraryUrl);
                            cc.settings.overrideSettings('assets', 'nativeBase', libraryUrl);
                            cc.settings.overrideSettings('assets', 'remoteBundles', []);
                            cc.settings.overrideSettings('assets', 'preloadBundles', []);
                        }

                        // Pre-fetch assets info for URL to UUID mapping
                        await fetchAssetsInfo();

                        console.log('[esengine] Project configured successfully');
                    }
                }
            },

            /**
             * @zh 加载场景（模仿 CLI 的 sceneUtils.runScene）
             * @en Load scene (mimicking CLI's sceneUtils.runScene)
             * @param {string} sceneUrl - 场景资源 URL（如 db://assets/scenes/login.scene）或 UUID
             */
            loadScene: async function(sceneUrl) {
                console.log('[esengine] Loading scene:', sceneUrl);

                if (!director) {
                    console.error('[esengine] Director not available');
                    return { success: false, error: 'Director not available' };
                }

                try {
                    const assetManager = cc.assetManager;
                    if (!assetManager) {
                        console.error('[esengine] AssetManager not available');
                        return { success: false, error: 'AssetManager not available' };
                    }

                    if (!projectLibraryUrl) {
                        console.error('[esengine] Project library URL not configured');
                        return { success: false, error: 'Project not configured' };
                    }

                    // Clear node and component path caches (like CLI does)
                    EditorExtends.Node.clear();
                    EditorExtends.Component.clear();

                    // Resolve UUID from URL or use as-is if already a UUID
                    let uuid = sceneUrl;
                    if (sceneUrl.startsWith('db://') || sceneUrl.includes('/') || sceneUrl.includes('\\')) {
                        uuid = await urlToUuid(sceneUrl);
                        if (!uuid) {
                            console.error('[esengine] Failed to resolve UUID for:', sceneUrl);
                            return { success: false, error: 'Failed to resolve scene UUID from URL' };
                        }
                        console.log('[esengine] Resolved UUID:', uuid);
                    }

                    // Load scene using assetManager.loadAny (like CLI's sceneUtils.loadAny)
                    console.log('[esengine] Loading scene with UUID:', uuid);

                    return new Promise((resolve) => {
                        // Remove from cache first to ensure fresh load
                        assetManager.assets.remove(uuid);

                        assetManager.loadAny(uuid, (err, sceneAsset) => {
                            if (err) {
                                console.error('[esengine] Failed to load scene:', err);
                                resolve({ success: false, error: err.message || String(err) });
                                return;
                            }

                            if (!sceneAsset) {
                                console.error('[esengine] Scene asset is null');
                                resolve({ success: false, error: 'Scene asset is null' });
                                return;
                            }

                            console.log('[esengine] Scene asset loaded:', sceneAsset._name || sceneAsset.name);

                            // Run the scene (like CLI's sceneUtils.runScene)
                            try {
                                director.runSceneImmediate(
                                    sceneAsset,
                                    () => { /* onLaunched callback */ },
                                    (runErr, instance) => {
                                        if (runErr || !instance) {
                                            console.error('[esengine] Failed to run scene:', runErr);
                                            resolve({ success: false, error: runErr?.message || 'Unknown error' });
                                            return;
                                        }

                                        scene = instance;
                                        console.log('[esengine] Scene running:', scene?.name);

                                        // Log node tree for debugging
                                        this.logNodeTree(scene);

                                        // Emit hierarchy changed to notify editor
                                        setTimeout(() => emitHierarchyChanged(), 100);

                                        resolve({ success: true, sceneName: scene?.name });
                                    }
                                );
                            } catch (runErr) {
                                console.error('[esengine] Failed to run scene:', runErr);
                                resolve({ success: false, error: runErr.message || String(runErr) });
                            }
                        });
                    });
                } catch (err) {
                    console.error('[esengine] Error loading scene:', err);
                    return { success: false, error: String(err) };
                }
            },

            /**
             * @zh 打印节点树用于调试
             * @en Log node tree for debugging
             */
            logNodeTree: function(node, indent = 0) {
                const prefix = '  '.repeat(indent);
                const uiTransform = node.getComponent && node.getComponent('cc.UITransform');
                const sizeInfo = uiTransform ? `[${uiTransform.width}x${uiTransform.height}]` : '';
                console.log(`${prefix}${node.name} ${sizeInfo}`);
                if (node.children && indent < 3) {
                    for (const child of node.children) {
                        this.logNodeTree(child, indent + 1);
                    }
                }
            },

            /**
             * @zh 从场景数据创建节点（用于 MCP 同步）
             * @en Create nodes from scene data (for MCP sync)
             * @param {Object} sceneData - MCP 返回的场景树数据
             */
            syncSceneFromData: function(sceneData) {
                if (!scene || !sceneData) {
                    console.warn('[esengine] Cannot sync: scene or data not available');
                    return;
                }

                console.log('[esengine] Syncing scene from data:', sceneData.name);

                // Clear existing children (except camera)
                const children = [...scene.children];
                for (const child of children) {
                    if (child.name !== 'Main Camera') {
                        child.destroy();
                    }
                }

                // Clear tracked nodes
                sceneNodes = [];

                // Track bounding box for auto-fit camera
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let hasUICoordinates = false;

                // Create nodes from data and track their positions
                function createNode(nodeData, parent, parentPath) {
                    const node = new cc.Node(nodeData.name);
                    parent.addChild(node);

                    // Build node path
                    const nodePath = parentPath ? `${parentPath}/${nodeData.name}` : nodeData.name;

                    // Default position
                    let position = { x: 0, y: 0, z: 0 };

                    // Apply transform if available
                    if (nodeData.properties) {
                        const props = nodeData.properties;
                        if (props.position) {
                            position = {
                                x: props.position.x || 0,
                                y: props.position.y || 0,
                                z: props.position.z || 0
                            };
                            node.setPosition(position.x, position.y, position.z);

                            // Update bounding box
                            minX = Math.min(minX, position.x);
                            maxX = Math.max(maxX, position.x);
                            minY = Math.min(minY, position.y);
                            maxY = Math.max(maxY, position.y);

                            // Detect UI coordinates (typically > 50 units)
                            if (Math.abs(position.x) > 50 || Math.abs(position.y) > 50) {
                                hasUICoordinates = true;
                            }
                        }
                        if (props.scale) {
                            node.setScale(props.scale.x || 1, props.scale.y || 1, props.scale.z || 1);
                        }
                        if (props.eulerAngles) {
                            node.setRotationFromEuler(props.eulerAngles.x || 0, props.eulerAngles.y || 0, props.eulerAngles.z || 0);
                        }
                        node.active = props.active !== false;
                    }

                    // Track this node for marker rendering
                    sceneNodes.push({
                        uuid: nodeData.uuid || nodePath,
                        name: nodeData.name,
                        path: nodePath,
                        position: position,
                        node: node
                    });

                    // Recursively create children
                    if (nodeData.children) {
                        for (const childData of nodeData.children) {
                            createNode(childData, node, nodePath);
                        }
                    }

                    return node;
                }

                // Create root nodes
                if (sceneData.children) {
                    for (const childData of sceneData.children) {
                        createNode(childData, scene, '');
                    }
                }

                // Auto-fit camera for UI scenes
                if (hasUICoordinates && sceneNodes.length > 0 && isFinite(minX)) {
                    // Calculate center and extent
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    const extentX = Math.max(100, (maxX - minX) / 2);
                    const extentY = Math.max(100, (maxY - minY) / 2);
                    const extent = Math.max(extentX, extentY) * 1.2; // Add 20% padding

                    // Update camera target and ortho size for 2D mode
                    cameraTarget.x = centerX;
                    cameraTarget.y = centerY;
                    orthoSize = extent;

                    console.log('[esengine] UI scene detected, auto-fit camera:', {
                        center: { x: centerX, y: centerY },
                        extent: extent,
                        bounds: { minX, maxX, minY, maxY }
                    });

                    // If in 2D mode, update camera immediately
                    if (viewMode === '2d') {
                        updateCameraView();
                    }
                }

                console.log('[esengine] Scene synced, node count:', scene.children.length, 'tracked markers:', sceneNodes.length);
            },

            /**
             * @zh 设置选中的节点（用于高亮显示）
             * @en Set selected node (for highlighting)
             * @param {string} uuid - 节点 UUID 或路径
             */
            selectNode: function(uuid) {
                selectedNodeUuid = uuid;
                console.log('[esengine] Selected node:', uuid);
            },

            /**
             * @zh 设置节点标记可见性
             * @en Set node markers visibility
             * @param {boolean} visible - 是否显示节点标记
             */
            setNodeMarkersVisible: function(visible) {
                nodeMarkersVisible = visible;
                console.log('[esengine] Node markers visible:', visible);
            },

            /**
             * @zh 设置相机近裁剪面距离
             * @en Set camera near clipping plane distance
             * @param {number} distance - 近裁剪面距离
             */
            setCameraNearPlane: function(distance) {
                if (mainCameraComp && typeof distance === 'number' && distance > 0) {
                    mainCameraComp.near = distance;
                    console.log('[esengine] Camera near plane set to:', distance);
                }
            },

            /**
             * @zh 获取当前相机近裁剪面距离
             * @en Get current camera near clipping plane distance
             * @returns {number} - 近裁剪面距离
             */
            getCameraNearPlane: function() {
                return mainCameraComp ? mainCameraComp.near : 0.1;
            },

            /**
             * @zh 设置相机远裁剪面距离
             * @en Set camera far clipping plane distance
             * @param {number} distance - 远裁剪面距离
             */
            setCameraFarPlane: function(distance) {
                if (mainCameraComp && typeof distance === 'number' && distance > 0) {
                    mainCameraComp.far = distance;
                    console.log('[esengine] Camera far plane set to:', distance);
                }
            },

            /**
             * @zh 获取当前相机远裁剪面距离
             * @en Get current camera far clipping plane distance
             * @returns {number} - 远裁剪面距离
             */
            getCameraFarPlane: function() {
                return mainCameraComp ? mainCameraComp.far : 100000;
            },

            /**
             * @zh 设置相机视野角度 (FOV)
             * @en Set camera field of view (FOV)
             * @param {number} fov - 视野角度（度）
             */
            setCameraFOV: function(fov) {
                if (mainCameraComp && typeof fov === 'number' && fov > 0 && fov < 180) {
                    mainCameraComp.fov = fov;
                    console.log('[esengine] Camera FOV set to:', fov);
                }
            },

            /**
             * @zh 获取当前相机视野角度
             * @en Get current camera field of view
             * @returns {number} - 视野角度（度）
             */
            getCameraFOV: function() {
                return mainCameraComp ? mainCameraComp.fov : 60;
            }
        };

        // Camera controls: RMB=look, MMB=pan, scroll=zoom, WASD+RMB=move
        function setupCameraControls() {
            const canvas = document.getElementById('GameCanvas');
            if (!canvas) return;

            let isDragging = false;
            let isPanning = false;
            let lastX = 0;
            let lastY = 0;

            // Track pressed keys for movement
            const keysPressed = {};

            // Movement speed
            const moveSpeed = 0.5;

            // Mouse wheel: zoom / move forward-backward
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                if (viewMode === '2d') {
                    const delta = e.deltaY > 0 ? 1.1 : 0.9;
                    orthoSize *= delta;
                    orthoSize = Math.max(1, Math.min(100, orthoSize));
                } else {
                    // Move camera forward/backward along view direction
                    const forward = getCameraForward();
                    const distance = e.deltaY > 0 ? -2 : 2;
                    cameraPos.x += forward.x * distance;
                    cameraPos.y += forward.y * distance;
                    cameraPos.z += forward.z * distance;
                }
                updateCameraView();
            }, { passive: false });

            // Mouse down
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    // Right button: free look rotate (3D) or disabled (2D)
                    if (viewMode === '3d') {
                        isDragging = true;
                        canvas.requestPointerLock?.();
                    }
                } else if (e.button === 1) {
                    // Middle button: pan
                    isPanning = true;
                }
                lastX = e.clientX;
                lastY = e.clientY;
            });

            // Mouse move
            canvas.addEventListener('mousemove', (e) => {
                const dx = e.movementX ?? (e.clientX - lastX);
                const dy = e.movementY ?? (e.clientY - lastY);
                lastX = e.clientX;
                lastY = e.clientY;

                if (isDragging && viewMode === '3d') {
                    // Free look: rotate camera in place (FPS style)
                    cameraYaw -= dx * 0.3;
                    cameraPitch -= dy * 0.3;
                    cameraPitch = Math.max(-89, Math.min(89, cameraPitch));
                    updateCameraView();
                } else if (isPanning) {
                    if (viewMode === '2d') {
                        // Pan in 2D
                        const scale = orthoSize / canvas.height * 2;
                        cameraTarget.x -= dx * scale;
                        cameraTarget.y += dy * scale;
                    } else {
                        // Pan in 3D (move camera position along camera plane)
                        const right = getCameraRight();
                        const scale = 0.05;

                        // Move along right axis (dx) and up axis (dy)
                        cameraPos.x -= right.x * dx * scale;
                        cameraPos.z -= right.z * dx * scale;
                        cameraPos.y += dy * scale;
                    }
                    updateCameraView();
                }
            });

            // Mouse up
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 2) {
                    isDragging = false;
                    document.exitPointerLock?.();
                } else if (e.button === 1) {
                    isPanning = false;
                }
            });

            // Mouse leave
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                isPanning = false;
                document.exitPointerLock?.();
            });

            // Prevent context menu
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Keyboard controls for movement while right-clicking
            window.addEventListener('keydown', (e) => {
                keysPressed[e.key.toLowerCase()] = true;
            });

            window.addEventListener('keyup', (e) => {
                keysPressed[e.key.toLowerCase()] = false;
            });

            // Movement loop (only when right-click dragging)
            function updateMovement() {
                if (isDragging && viewMode === '3d') {
                    const forward = getCameraForward();
                    const right = getCameraRight();

                    if (keysPressed['w']) {
                        cameraPos.x += forward.x * moveSpeed;
                        cameraPos.y += forward.y * moveSpeed;
                        cameraPos.z += forward.z * moveSpeed;
                    }
                    if (keysPressed['s']) {
                        cameraPos.x -= forward.x * moveSpeed;
                        cameraPos.y -= forward.y * moveSpeed;
                        cameraPos.z -= forward.z * moveSpeed;
                    }
                    if (keysPressed['a']) {
                        cameraPos.x -= right.x * moveSpeed;
                        cameraPos.z -= right.z * moveSpeed;
                    }
                    if (keysPressed['d']) {
                        cameraPos.x += right.x * moveSpeed;
                        cameraPos.z += right.z * moveSpeed;
                    }
                    if (keysPressed['e'] || keysPressed[' ']) {
                        cameraPos.y += moveSpeed;
                    }
                    if (keysPressed['q']) {
                        cameraPos.y -= moveSpeed;
                    }

                    if (keysPressed['w'] || keysPressed['s'] || keysPressed['a'] || keysPressed['d'] || keysPressed['e'] || keysPressed['q'] || keysPressed[' ']) {
                        updateCameraView();
                    }
                }
                requestAnimationFrame(updateMovement);
            }
            updateMovement();

            console.log('[ccesengine] Camera controls enabled (free look mode)');
        }

        function setupAxisIndicator() {
            const canvas = document.getElementById('axisIndicator');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const size = 80;
            const center = size;
            const axisLength = 30;

            function drawAxis() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Calculate rotation matrix from camera angles
                const pitchRad = -cameraPitch * Math.PI / 180;
                const yawRad = -cameraYaw * Math.PI / 180;

                const cosPitch = Math.cos(pitchRad);
                const sinPitch = Math.sin(pitchRad);
                const cosYaw = Math.cos(yawRad);
                const sinYaw = Math.sin(yawRad);

                // Transform world axes to screen space
                // X axis (red)
                const xEnd = {
                    x: center + axisLength * cosYaw,
                    y: center + axisLength * sinPitch * sinYaw
                };

                // Y axis (green) - up
                const yEnd = {
                    x: center,
                    y: center - axisLength * cosPitch
                };

                // Z axis (blue)
                const zEnd = {
                    x: center - axisLength * sinYaw,
                    y: center + axisLength * sinPitch * cosYaw
                };

                // Draw axes with depth sorting
                const axes = [
                    { end: xEnd, color: '#dc3c3c', label: 'X', depth: -cosYaw },
                    { end: yEnd, color: '#3cdc3c', label: 'Y', depth: cosPitch },
                    { end: zEnd, color: '#3c3cdc', label: 'Z', depth: sinYaw }
                ];

                // Sort by depth (draw far axes first)
                axes.sort((a, b) => a.depth - b.depth);

                // Draw each axis
                for (const axis of axes) {
                    ctx.beginPath();
                    ctx.moveTo(center, center);
                    ctx.lineTo(axis.end.x, axis.end.y);
                    ctx.strokeStyle = axis.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw arrow head
                    const dx = axis.end.x - center;
                    const dy = axis.end.y - center;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 0) {
                        const nx = dx / len;
                        const ny = dy / len;
                        const arrowSize = 6;
                        ctx.beginPath();
                        ctx.moveTo(axis.end.x, axis.end.y);
                        ctx.lineTo(axis.end.x - arrowSize * nx + arrowSize * 0.5 * ny, axis.end.y - arrowSize * ny - arrowSize * 0.5 * nx);
                        ctx.lineTo(axis.end.x - arrowSize * nx - arrowSize * 0.5 * ny, axis.end.y - arrowSize * ny + arrowSize * 0.5 * nx);
                        ctx.closePath();
                        ctx.fillStyle = axis.color;
                        ctx.fill();
                    }

                    // Draw label
                    ctx.font = 'bold 11px sans-serif';
                    ctx.fillStyle = axis.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const labelOffset = 12;
                    const labelX = axis.end.x + (dx / len) * labelOffset;
                    const labelY = axis.end.y + (dy / len) * labelOffset;
                    ctx.fillText(axis.label, labelX, labelY);
                }

                // Draw center circle
                ctx.beginPath();
                ctx.arc(center, center, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#888';
                ctx.fill();

                requestAnimationFrame(drawAxis);
            }

            drawAxis();
            console.log('[ccesengine] Axis indicator enabled');
        }

        function extractComponents(node) {
            const components = [];
            if (node.components) {
                for (const comp of node.components) {
                    let typeName = comp.constructor?.name || 'Component';
                    if (typeName.startsWith('cc.')) typeName = typeName.substring(3);
                    components.push(typeName);
                }
            }
            return components;
        }

        function extractNodeProperties(node) {
            const pos = node.position || { x: 0, y: 0, z: 0 };
            const scale = node.scale || { x: 1, y: 1, z: 1 };
            const euler = node.eulerAngles || { x: 0, y: 0, z: 0 };

            return {
                position: { x: pos.x, y: pos.y, z: pos.z },
                scale: { x: scale.x, y: scale.y, z: scale.z },
                eulerAngles: { x: euler.x, y: euler.y, z: euler.z },
                active: node.active !== false
            };
        }

        function buildNodeData(node, depth = 0) {
            if (depth > 50) {
                return null;
            }

            const nodeData = {
                uuid: node.uuid || '',
                name: node.name || 'Node',
                active: node.active !== false,
                children: [],
                components: extractComponents(node),
                properties: extractNodeProperties(node)
            };

            if (node.children) {
                for (const child of node.children) {
                    const childData = buildNodeData(child, depth + 1);
                    if (childData) nodeData.children.push(childData);
                }
            }

            return nodeData;
        }

        function getSceneTree() {
            if (!scene) {
                return {
                    uuid: '',
                    name: 'No Scene',
                    active: true,
                    children: [],
                    components: []
                };
            }

            return buildNodeData(scene);
        }

        function findNodeByUuid(uuid) {
            if (!scene || !uuid) return null;

            function searchNode(node) {
                if (node.uuid === uuid) return node;
                if (node.children) {
                    for (const child of node.children) {
                        const found = searchNode(child);
                        if (found) return found;
                    }
                }
                return null;
            }

            return searchNode(scene);
        }

        function getNodeProperties(uuid) {
            const node = findNodeByUuid(uuid);
            if (!node) {
                return null;
            }

            const pos = node.position || { x: 0, y: 0, z: 0 };
            const euler = node.eulerAngles || { x: 0, y: 0, z: 0 };
            const scale = node.scale || { x: 1, y: 1, z: 1 };

            // Build component data with properties
            const components = [];
            if (node.components) {
                for (const comp of node.components) {
                    let typeName = comp.constructor?.name || 'Component';
                    if (typeName.startsWith('cc.')) {
                        typeName = typeName.substring(3);
                    }

                    const compData = {
                        type: typeName,
                        uuid: comp.uuid || '',
                        enabled: comp.enabled !== false,
                        properties: {}
                    };

                    // Extract common component properties
                    try {
                        if (typeName === 'UITransform') {
                            compData.properties.contentSize = {
                                type: 'vec2',
                                value: { value: [comp.width || 0, comp.height || 0] }
                            };
                            compData.properties.anchorPoint = {
                                type: 'vec2',
                                value: { value: [comp.anchorX || 0.5, comp.anchorY || 0.5] }
                            };
                        } else if (typeName === 'Sprite') {
                            compData.properties.spriteFrame = {
                                type: 'asset',
                                value: { value: comp.spriteFrame?._uuid || null, assetType: 'SpriteFrame' }
                            };
                            compData.properties.sizeMode = {
                                type: 'enum',
                                value: { value: comp.sizeMode || 0, options: ['CUSTOM', 'TRIMMED', 'RAW'] }
                            };
                        } else if (typeName === 'Label') {
                            compData.properties.string = {
                                type: 'string',
                                value: { value: comp.string || '' }
                            };
                            compData.properties.fontSize = {
                                type: 'number',
                                value: { value: comp.fontSize || 40 }
                            };
                            compData.properties.color = {
                                type: 'color',
                                value: { value: comp.color ? [comp.color.r/255, comp.color.g/255, comp.color.b/255, comp.color.a/255] : [1,1,1,1] }
                            };
                        } else if (typeName === 'Camera') {
                            compData.properties.clearFlags = {
                                type: 'enum',
                                value: { value: comp.clearFlags || 0, options: ['NONE', 'COLOR', 'DEPTH', 'STENCIL', 'COLOR_DEPTH', 'COLOR_STENCIL', 'DEPTH_STENCIL', 'ALL'] }
                            };
                            compData.properties.projection = {
                                type: 'enum',
                                value: { value: comp.projection || 0, options: ['ORTHO', 'PERSPECTIVE'] }
                            };
                            compData.properties.fov = {
                                type: 'number',
                                value: { value: comp.fov || 60 }
                            };
                        }
                    } catch (e) {
                        console.warn('[getNodeProperties] Error extracting component properties:', typeName, e);
                    }

                    components.push(compData);
                }
            }

            return {
                uuid: node.uuid || '',
                name: node.name || 'Node',
                active: node.active !== false,
                position: [pos.x, pos.y, pos.z],
                rotation: [euler.x, euler.y, euler.z],
                scale: [scale.x, scale.y, scale.z],
                components: components
            };
        }

        function emitHierarchyChanged() {
            if (!rpc) return;

            const treeData = getSceneTree();
            rpc.notify('scene.hierarchyChanged', { tree: treeData });
            console.log('[Viewport] Emitted hierarchyChanged, nodes:', treeData.children?.length || 0);
        }

        function registerSceneRpcMethods() {
            if (!rpc) return;

            rpc.registerMethod('scene.getTree', () => {
                const tree = getSceneTree();
                console.log('[RPC] scene.getTree - nodes:', tree.children?.length || 0);
                return tree;
            });

            rpc.registerMethod('scene.getNodeProperties', (params) => {
                const uuid = params?.uuid;
                if (!uuid) {
                    throw new Error('Missing uuid parameter');
                }
                const props = getNodeProperties(uuid);
                if (!props) {
                    throw new Error('Node not found: ' + uuid);
                }
                console.log('[RPC] scene.getNodeProperties -', props.name);
                return props;
            });

            rpc.registerMethod('scene.selectNode', (params) => {
                const uuid = params?.uuid || null;
                selectedNodeUuid = uuid;
                console.log('[RPC] scene.selectNode:', uuid);
                return { selected: uuid };
            });

            rpc.registerMethod('scene.setNodeProperty', (params) => {
                const { uuid, path, value } = params || {};
                if (!uuid || !path) {
                    throw new Error('Missing uuid or path parameter');
                }

                const node = findNodeByUuid(uuid);
                if (!node) {
                    throw new Error('Node not found: ' + uuid);
                }

                // Parse path and set value
                const parts = path.split('.');
                let target = node;
                for (let i = 0; i < parts.length - 1; i++) {
                    target = target[parts[i]];
                    if (!target) {
                        throw new Error('Invalid path: ' + path);
                    }
                }
                const lastPart = parts[parts.length - 1];
                target[lastPart] = value;

                console.log('[RPC] scene.setNodeProperty:', uuid, path, '=', value);
                return { success: true };
            });

            console.log('[Viewport] Scene RPC methods registered');
        }

        // Register scene RPC methods immediately
        registerSceneRpcMethods();

        // Setup camera controls after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            // Wait for main() to complete then setup controls
            setTimeout(setupCameraControls, 100);
            setTimeout(setupAxisIndicator, 100);
        });

        main();
    </script>
</body>
</html>
