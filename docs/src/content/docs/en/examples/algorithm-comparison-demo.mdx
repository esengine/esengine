---
title: "Pathfinding Algorithm Comparison"
description: "Compare A*, Bidirectional A*, and JPS algorithm performance and search process"
---

import DemoPlayground from '../../../../components/DemoPlayground.vue';

export const algoScenes = [
    { id: 'open', label: '○', name: 'Open Terrain' },
    { id: 'maze', label: '⬛', name: 'Maze' },
    { id: 'rooms', label: '⬜', name: 'Rooms' },
    { id: 'dense', label: '▓', name: 'Dense Obstacles' }
];

export const algoParams = [
    { id: 'gridSize', label: 'Grid', desc: 'Grid size', value: 60, min: 30, max: 100, step: 10 },
    { id: 'obstacleRate', label: 'Obstacles', desc: 'Obstacle density (%)', value: 30, min: 10, max: 50, step: 5 }
];

export const algoDemoCode = `// Pathfinding Algorithm Comparison - A* vs Bidirectional A* vs JPS
// ============================================
// Compare search efficiency and path quality of different algorithms

const {
    Core, Scene, Component, EntitySystem, Matcher, Time,
    ECSComponent, ECSSystem,
    GridMap, createGridMap,
    AStarPathfinder, GridPathfinder, JPSPathfinder,
    octileDistance
} = ESEngine;

const WIDTH = 580, HEIGHT = 380;

const params = window.__demoParams || {
    gridSize: 60, obstacleRate: 30
};

// Algorithm results storage
let results = {
    astar: { time: 0, nodes: 0, pathLen: 0, path: [] },
    bidir: { time: 0, nodes: 0, pathLen: 0, path: [] },
    jps: { time: 0, nodes: 0, pathLen: 0, path: [] }
};

let gridMap = null;
let startPos = { x: 2, y: 2 };
let endPos = { x: 0, y: 0 };
let selectedAlgo = 'all'; // 'all', 'astar', 'bidir', 'jps'

// ============================================
// Rendering
// ============================================

function render(ctx) {
    if (!gridMap) return;

    const cellW = WIDTH / gridMap.width;
    const cellH = HEIGHT / gridMap.height;

    // Clear screen
    ctx.fillStyle = '#16213e';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Draw obstacles
    ctx.fillStyle = '#2d4263';
    for (let y = 0; y < gridMap.height; y++) {
        for (let x = 0; x < gridMap.width; x++) {
            if (!gridMap.isWalkable(x, y)) {
                ctx.fillRect(x * cellW, y * cellH, cellW - 1, cellH - 1);
            }
        }
    }

    // Draw grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for (let x = 0; x <= gridMap.width; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellW, 0);
        ctx.lineTo(x * cellW, HEIGHT);
        ctx.stroke();
    }
    for (let y = 0; y <= gridMap.height; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellH);
        ctx.lineTo(WIDTH, y * cellH);
        ctx.stroke();
    }

    // Draw paths
    const colors = {
        astar: { stroke: '#ff6b6b', fill: 'rgba(255,107,107,0.3)', name: 'A*' },
        bidir: { stroke: '#4ecdc4', fill: 'rgba(78,205,196,0.3)', name: 'Bidirectional' },
        jps: { stroke: '#ffe66d', fill: 'rgba(255,230,109,0.3)', name: 'JPS' }
    };

    const drawPath = (path, color, offset) => {
        if (path.length < 2) return;
        ctx.strokeStyle = color.stroke;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(path[0].x * cellW + cellW/2 + offset, path[0].y * cellH + cellH/2);
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x * cellW + cellW/2 + offset, path[i].y * cellH + cellH/2);
        }
        ctx.stroke();
    };

    // Show paths based on selection
    if (selectedAlgo === 'all' || selectedAlgo === 'astar') {
        drawPath(results.astar.path, colors.astar, -2);
    }
    if (selectedAlgo === 'all' || selectedAlgo === 'bidir') {
        drawPath(results.bidir.path, colors.bidir, 0);
    }
    if (selectedAlgo === 'all' || selectedAlgo === 'jps') {
        drawPath(results.jps.path, colors.jps, 2);
    }

    // Draw start and end points
    ctx.fillStyle = '#00d4ff';
    ctx.beginPath();
    ctx.arc(startPos.x * cellW + cellW/2, startPos.y * cellH + cellH/2, 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(endPos.x * cellW + cellW/2, endPos.y * cellH + cellH/2, 6, 0, Math.PI * 2);
    ctx.fill();

    // HUD - Algorithm comparison panel
    const panelX = 5, panelY = 5;
    const panelW = 200, panelH = 95;
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.fillRect(panelX, panelY, panelW, panelH);

    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText('Algorithm Comparison', panelX + 5, panelY + 15);

    ctx.font = '10px monospace';
    const algos = ['astar', 'bidir', 'jps'];
    const labels = ['A*', 'Bi-A*', 'JPS'];

    // Header
    ctx.fillStyle = '#888';
    ctx.fillText('Algo    Time    Nodes   Path', panelX + 5, panelY + 30);

    algos.forEach((algo, i) => {
        const r = results[algo];
        const y = panelY + 45 + i * 15;
        ctx.fillStyle = colors[algo].stroke;
        ctx.fillText(
            \`\${labels[i].padEnd(6)} \${r.time.toFixed(2).padStart(6)}ms \${String(r.nodes).padStart(5)} \${String(r.pathLen).padStart(5)}\`,
            panelX + 5, y
        );
    });

    // Hint
    ctx.fillStyle = '#666';
    ctx.font = '9px monospace';
    ctx.fillText('Click: set start/end', panelX + 5, panelY + 90);

    // Legend
    const legendX = WIDTH - 95, legendY = 5;
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.fillRect(legendX, legendY, 90, 55);
    ctx.font = '10px monospace';
    algos.forEach((algo, i) => {
        ctx.fillStyle = colors[algo].stroke;
        ctx.fillRect(legendX + 5, legendY + 8 + i * 15, 10, 10);
        ctx.fillText(labels[i], legendX + 20, legendY + 17 + i * 15);
    });
}

// ============================================
// Pathfinding Execution
// ============================================

function runPathfinding() {
    if (!gridMap) return;

    const options = {
        allowDiagonal: true,
        heuristic: octileDistance
    };

    // Standard A*
    const astar = new AStarPathfinder(gridMap);
    let t0 = performance.now();
    let result = astar.findPath(startPos.x, startPos.y, endPos.x, endPos.y, options);
    results.astar = {
        time: performance.now() - t0,
        nodes: result.nodesSearched,
        pathLen: result.path.length,
        path: result.path
    };

    // Bidirectional A*
    const bidir = new GridPathfinder(gridMap, { mode: 'bidirectional' });
    t0 = performance.now();
    result = bidir.findPath(startPos.x, startPos.y, endPos.x, endPos.y, options);
    results.bidir = {
        time: performance.now() - t0,
        nodes: result.nodesSearched,
        pathLen: result.path.length,
        path: result.path
    };

    // JPS
    const jps = new JPSPathfinder(gridMap);
    t0 = performance.now();
    result = jps.findPath(startPos.x, startPos.y, endPos.x, endPos.y, { allowDiagonal: true });
    results.jps = {
        time: performance.now() - t0,
        nodes: result.nodesSearched,
        pathLen: result.path.length,
        path: result.path
    };
}

// ============================================
// Map Generation
// ============================================

function generateMap(type) {
    const w = params.gridSize;
    const h = Math.floor(w * HEIGHT / WIDTH);

    gridMap = createGridMap(w, h);

    const generators = {
        open: () => {
            // Few random obstacles
            const rate = 0.1;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (Math.random() < rate) gridMap.setWalkable(x, y, false);
                }
            }
        },
        maze: () => {
            // Maze
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    gridMap.setWalkable(x, y, false);
                }
            }
            const carve = (x, y) => {
                gridMap.setWalkable(x, y, true);
                const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(() => Math.random() - 0.5);
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < w-1 && ny > 0 && ny < h-1 && !gridMap.isWalkable(nx, ny)) {
                        gridMap.setWalkable(x + dx/2, y + dy/2, true);
                        carve(nx, ny);
                    }
                }
            };
            carve(1, 1);
        },
        rooms: () => {
            // Room layout
            const roomW = Math.floor(w / 4);
            const roomH = Math.floor(h / 3);
            for (let ry = 0; ry < 3; ry++) {
                for (let rx = 0; rx < 4; rx++) {
                    const bx = rx * roomW, by = ry * roomH;
                    for (let x = bx; x < bx + roomW && x < w; x++) {
                        if (by < h) gridMap.setWalkable(x, by, false);
                        if (by + roomH - 1 < h) gridMap.setWalkable(x, by + roomH - 1, false);
                    }
                    for (let y = by; y < by + roomH && y < h; y++) {
                        if (bx < w) gridMap.setWalkable(bx, y, false);
                        if (bx + roomW - 1 < w) gridMap.setWalkable(bx + roomW - 1, y, false);
                    }
                    // Doors
                    const doorX = bx + Math.floor(roomW / 2);
                    const doorY = by + Math.floor(roomH / 2);
                    if (doorX < w && by < h) gridMap.setWalkable(doorX, by, true);
                    if (doorX < w && by + roomH - 1 < h) gridMap.setWalkable(doorX, by + roomH - 1, true);
                    if (bx < w && doorY < h) gridMap.setWalkable(bx, doorY, true);
                    if (bx + roomW - 1 < w && doorY < h) gridMap.setWalkable(bx + roomW - 1, doorY, true);
                }
            }
        },
        dense: () => {
            // Dense random obstacles
            const rate = params.obstacleRate / 100;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (Math.random() < rate) gridMap.setWalkable(x, y, false);
                }
            }
        }
    };

    generators[type]?.();

    // Set start and end
    startPos = findWalkable(2, 2);
    endPos = findWalkable(w - 3, h - 3);

    runPathfinding();
}

function findWalkable(px, py) {
    if (gridMap.isWalkable(px, py)) return { x: px, y: py };
    for (let r = 1; r < 20; r++) {
        for (let dx = -r; dx <= r; dx++) {
            for (let dy = -r; dy <= r; dy++) {
                const x = px + dx, y = py + dy;
                if (x >= 0 && x < gridMap.width && y >= 0 && y < gridMap.height) {
                    if (gridMap.isWalkable(x, y)) return { x, y };
                }
            }
        }
    }
    return { x: 1, y: 1 };
}

// ============================================
// Initialize
// ============================================

generateMap('open');

// Mouse interaction
let clickMode = 'start'; // 'start' or 'end'
canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const cellW = WIDTH / gridMap.width;
    const cellH = HEIGHT / gridMap.height;
    const gx = Math.floor(mx / cellW);
    const gy = Math.floor(my / cellH);

    if (gridMap.isWalkable(gx, gy)) {
        if (clickMode === 'start') {
            startPos = { x: gx, y: gy };
            clickMode = 'end';
        } else {
            endPos = { x: gx, y: gy };
            clickMode = 'start';
        }
        runPathfinding();
    }
});

// Scene switching support
window.__demoScene = {
    loadScenario: (type) => {
        generateMap(type);
    }
};

// Game loop
function gameLoop() {
    render(ctx);
    requestAnimationFrame(gameLoop);
}

gameLoop();`;

This is a **pathfinding algorithm comparison demo** showing performance differences between A*, Bidirectional A*, and JPS algorithms.

Click **Run** to start. Click on the map to set start/end points and observe the search efficiency of different algorithms.

**Algorithm Characteristics:**
- **A*** - Classic heuristic search, suitable for small to medium maps
- **Bidirectional A*** - Searches from both start and end simultaneously, more efficient for large maps
- **JPS (Jump Point Search)** - Significant advantage on open terrain, can skip many nodes

<DemoPlayground
    client:load
    title="Algorithm Comparison - A* vs Bidirectional A* vs JPS"
    code={algoDemoCode}
    canvasWidth={580}
    canvasHeight={380}
    scenes={algoScenes}
    params={algoParams}
/>

<script is:inline src="/esengine/js/esengine.iife.js"></script>

## Performance Metrics

| Metric | Description |
|--------|-------------|
| **Time** | Pathfinding time (milliseconds) |
| **Nodes** | Number of nodes searched (fewer = more efficient) |
| **Path** | Final path length (node count) |

## Scene Descriptions

- **Open Terrain** - JPS shows significant advantage, can skip large empty areas
- **Maze** - Narrow corridors, smaller difference between algorithms
- **Rooms** - Simulates indoor environment, requires passing through doorways
- **Dense Obstacles** - Random distribution, tests general cases

## Related Documentation

- [A* Pathfinding Demo](/esengine/en/examples/astar-pathfinding-demo) - Basic A* demo
- [Pathfinding System API](/esengine/en/modules/pathfinding) - Complete API documentation
