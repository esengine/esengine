---
title: "A* Pathfinding Demo"
description: "Interactive A* grid pathfinding demo using ECS architecture"
---

import DemoPlayground from '../../../../components/DemoPlayground.vue';

export const astarScenes = [
    { id: 'maze', label: '⬛', name: 'Maze' },
    { id: 'random', label: '✦', name: 'Random Obstacles' },
    { id: 'rooms', label: '⬜', name: 'Rooms' },
    { id: 'spiral', label: '◎', name: 'Spiral' }
];

export const astarParams = [
    { id: 'gridSize', label: 'Grid', desc: 'Grid size (higher = finer)', value: 40, min: 20, max: 80, step: 10 },
    { id: 'obstacleRate', label: 'Obstacles', desc: 'Obstacle density (%)', value: 25, min: 10, max: 50, step: 5 },
    { id: 'diagonal', label: 'Diagonal', desc: 'Allow diagonal movement (0=no, 1=yes)', value: 1, min: 0, max: 1, step: 1 },
    { id: 'speed', label: 'Speed', desc: 'Movement speed (grids/sec)', value: 5, min: 1, max: 15, step: 1 }
];

export const astarDemoCode = `// A* Pathfinding - ECS Architecture Demo
// ============================================
// Click the map to set start and end points, observe A* pathfinding process

const {
    Core, Scene, Component, EntitySystem, Matcher, Time,
    ECSComponent, ECSSystem,
    PathfindingAgentComponent, PathfindingMapComponent, PathfindingSystem
} = ESEngine;

const WIDTH = 580, HEIGHT = 380;

const params = window.__demoParams || {
    gridSize: 40, obstacleRate: 25, diagonal: 1, speed: 5
};

// ============================================
// Component Definitions
// ============================================

@ECSComponent('Visual')
class VisualComponent extends Component {
    color = '#00d4ff';
    showPath = true;
}

// ============================================
// Render System
// ============================================

@ECSSystem('Render', { updateOrder: 100 })
class RenderSystem extends EntitySystem {
    ctx: CanvasRenderingContext2D;
    mapComp: PathfindingMapComponent | null = null;
    fps = 0; frameCount = 0; lastFpsTime = 0;

    constructor(context: CanvasRenderingContext2D) {
        super(Matcher.all(PathfindingAgentComponent, VisualComponent));
        this.ctx = context;
    }

    process(entities) {
        const ctx = this.ctx;

        // Clear screen
        ctx.fillStyle = '#16213e';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // Find map component
        if (!this.mapComp) {
            const mapEntities = this.scene.entities.findEntitiesWithComponent(PathfindingMapComponent);
            if (mapEntities.length > 0) {
                this.mapComp = mapEntities[0].getComponent(PathfindingMapComponent);
            }
        }

        // Draw grid
        if (this.mapComp?.map) {
            const map = this.mapComp.map;
            const cellW = WIDTH / map.width;
            const cellH = HEIGHT / map.height;

            // Draw obstacles
            ctx.fillStyle = '#2d4263';
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    if (!map.isWalkable(x, y)) {
                        ctx.fillRect(x * cellW, y * cellH, cellW - 1, cellH - 1);
                    }
                }
            }

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= map.width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cellW, 0);
                ctx.lineTo(x * cellW, HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= map.height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cellH);
                ctx.lineTo(WIDTH, y * cellH);
                ctx.stroke();
            }
        }

        // FPS calculation
        this.frameCount++;
        const now = performance.now();
        if (now - this.lastFpsTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastFpsTime = now;
        }

        // Draw agents and paths
        for (const entity of entities) {
            const agent = entity.getComponent(PathfindingAgentComponent);
            const visual = entity.getComponent(VisualComponent);

            if (!this.mapComp?.map) continue;
            const cellW = WIDTH / this.mapComp.map.width;
            const cellH = HEIGHT / this.mapComp.map.height;

            // Draw path
            if (visual.showPath && agent.path.length > 0) {
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.4)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(agent.x * cellW + cellW/2, agent.y * cellH + cellH/2);
                for (const p of agent.path) {
                    ctx.lineTo(p.x * cellW + cellW/2, p.y * cellH + cellH/2);
                }
                ctx.stroke();

                // Draw path points
                ctx.fillStyle = 'rgba(0, 212, 255, 0.6)';
                for (let i = agent.pathIndex; i < agent.path.length; i++) {
                    const p = agent.path[i];
                    ctx.beginPath();
                    ctx.arc(p.x * cellW + cellW/2, p.y * cellH + cellH/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw target point
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(agent.targetX * cellW + cellW/2, agent.targetY * cellH + cellH/2, 6, 0, Math.PI * 2);
            ctx.fill();

            // Draw agent
            const x = agent.x * cellW + cellW/2;
            const y = agent.y * cellH + cellH/2;

            // Glow
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
            gradient.addColorStop(0, visual.color);
            gradient.addColorStop(1, 'transparent');
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Agent circle
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fillStyle = visual.color;
            ctx.fill();
        }

        // HUD
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(5, 5, 140, 50);
        ctx.fillStyle = '#00d4ff';
        ctx.font = '11px monospace';
        ctx.fillText(\`Grid: \${this.mapComp?.width || 0}x\${this.mapComp?.height || 0}\`, 10, 20);
        ctx.fillText(\`FPS: \${this.fps}\`, 10, 32);
        const agent = entities[0]?.getComponent(PathfindingAgentComponent);
        ctx.fillText(\`Path: \${agent?.path.length || 0} nodes\`, 10, 44);
    }
}

// ============================================
// Movement System
// ============================================

@ECSSystem('Movement', { updateOrder: 50 })
class MovementSystem extends EntitySystem {
    mapComp: PathfindingMapComponent | null = null;

    constructor() {
        super(Matcher.all(PathfindingAgentComponent));
    }

    process(entities) {
        if (!this.mapComp) {
            const mapEntities = this.scene.entities.findEntitiesWithComponent(PathfindingMapComponent);
            if (mapEntities.length > 0) {
                this.mapComp = mapEntities[0].getComponent(PathfindingMapComponent);
            }
        }
        if (!this.mapComp?.map) return;

        const cellW = WIDTH / this.mapComp.map.width;
        const cellH = HEIGHT / this.mapComp.map.height;
        const dt = Time.deltaTime;
        const moveSpeed = params.speed * dt;

        for (const entity of entities) {
            const agent = entity.getComponent(PathfindingAgentComponent);

            if (!agent.hasValidPath() || agent.isPathComplete()) continue;

            const waypoint = agent.getNextWaypoint();
            if (!waypoint) continue;

            const dx = waypoint.x - agent.x;
            const dy = waypoint.y - agent.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 0.1) {
                agent.x = waypoint.x;
                agent.y = waypoint.y;
                agent.advanceWaypoint();
            } else {
                const moveRatio = Math.min(moveSpeed / dist, 1);
                agent.x += dx * moveRatio;
                agent.y += dy * moveRatio;
            }
        }
    }
}

// ============================================
// Scene
// ============================================

class AStarDemoScene extends Scene {
    mapEntity: any;
    agentEntity: any;

    initialize() {
        this.name = 'AStarDemo';
        this.addSystem(new PathfindingSystem());
        this.addSystem(new MovementSystem());
        this.addSystem(new RenderSystem(ctx));
    }

    onStart() {
        this.loadScenario('maze');
    }

    loadScenario(type: string) {
        console.log('loadScenario called:', type);

        // Clear existing entities (use correct API)
        if (this.mapEntity) {
            this.mapEntity.destroy();
            this.mapEntity = null;
        }
        if (this.agentEntity) {
            this.agentEntity.destroy();
            this.agentEntity = null;
        }

        // Reset render system's map reference
        for (const system of this.systems) {
            if (system.mapComp) system.mapComp = null;
        }

        const gridSize = params.gridSize;

        // Create map entity
        this.mapEntity = this.createEntity('Map');
        const mapComp = this.mapEntity.addComponent(new PathfindingMapComponent());
        mapComp.width = gridSize;
        mapComp.height = Math.floor(gridSize * HEIGHT / WIDTH);
        mapComp.allowDiagonal = params.diagonal === 1;
        mapComp.avoidCorners = true;
        mapComp.enableSmoothing = false;

        // Create agent
        this.agentEntity = this.createEntity('Agent');
        const agent = this.agentEntity.addComponent(new PathfindingAgentComponent());
        const visual = this.agentEntity.addComponent(new VisualComponent());
        visual.color = '#00d4ff';

        // Wait for map initialization then generate obstacles
        setTimeout(() => {
            if (!mapComp.map) return;

            const generators = {
                maze: () => this.generateMaze(mapComp),
                random: () => this.generateRandom(mapComp),
                rooms: () => this.generateRooms(mapComp),
                spiral: () => this.generateSpiral(mapComp)
            };
            generators[type]?.();

            // Find start and end points (spiral: center to edge)
            let start, end;
            if (type === 'spiral') {
                const cx = Math.floor(mapComp.width / 2);
                const cy = Math.floor(mapComp.height / 2);
                start = { x: cx, y: cy };  // center
                end = this.findWalkable(mapComp, 1, 1);  // edge
            } else {
                start = this.findWalkable(mapComp, 1, 1);
                end = this.findWalkable(mapComp, mapComp.width - 2, mapComp.height - 2);
            }

            agent.x = start.x;
            agent.y = start.y;
            agent.requestPathTo(end.x, end.y);
        }, 100);
    }

    findWalkable(mapComp, preferX, preferY) {
        if (mapComp.isWalkable(preferX, preferY)) return { x: preferX, y: preferY };
        for (let r = 1; r < 10; r++) {
            for (let dx = -r; dx <= r; dx++) {
                for (let dy = -r; dy <= r; dy++) {
                    const x = preferX + dx, y = preferY + dy;
                    if (x >= 0 && x < mapComp.width && y >= 0 && y < mapComp.height) {
                        if (mapComp.isWalkable(x, y)) return { x, y };
                    }
                }
            }
        }
        return { x: 1, y: 1 };
    }

    generateMaze(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        // Fill all as walls
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                mapComp.setWalkable(x, y, false);
            }
        }
        // Recursive division maze generation
        const carve = (x, y) => {
            mapComp.setWalkable(x, y, true);
            const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(() => Math.random() - 0.5);
            for (const [dx, dy] of dirs) {
                const nx = x + dx, ny = y + dy;
                if (nx > 0 && nx < w-1 && ny > 0 && ny < h-1 && !mapComp.isWalkable(nx, ny)) {
                    mapComp.setWalkable(x + dx/2, y + dy/2, true);
                    carve(nx, ny);
                }
            }
        };
        carve(1, 1);
    }

    generateRandom(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        const rate = params.obstacleRate / 100;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (x === 1 && y === 1) continue;
                if (x === w-2 && y === h-2) continue;
                mapComp.setWalkable(x, y, Math.random() > rate);
            }
        }
    }

    generateRooms(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        // All walkable
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                mapComp.setWalkable(x, y, true);
            }
        }
        // Generate room walls
        const roomW = Math.floor(w / 4);
        const roomH = Math.floor(h / 3);
        for (let ry = 0; ry < 3; ry++) {
            for (let rx = 0; rx < 4; rx++) {
                const bx = rx * roomW, by = ry * roomH;
                // Draw walls
                for (let x = bx; x < bx + roomW && x < w; x++) {
                    if (by < h) mapComp.setWalkable(x, by, false);
                    if (by + roomH - 1 < h) mapComp.setWalkable(x, by + roomH - 1, false);
                }
                for (let y = by; y < by + roomH && y < h; y++) {
                    if (bx < w) mapComp.setWalkable(bx, y, false);
                    if (bx + roomW - 1 < w) mapComp.setWalkable(bx + roomW - 1, y, false);
                }
                // Open doors
                const doorX = bx + Math.floor(roomW / 2);
                const doorY = by + Math.floor(roomH / 2);
                if (doorX < w && by < h) mapComp.setWalkable(doorX, by, true);
                if (doorX < w && by + roomH - 1 < h) mapComp.setWalkable(doorX, by + roomH - 1, true);
                if (bx < w && doorY < h) mapComp.setWalkable(bx, doorY, true);
                if (bx + roomW - 1 < w && doorY < h) mapComp.setWalkable(bx + roomW - 1, doorY, true);
            }
        }
    }

    generateSpiral(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const maxDist = Math.min(cx, cy) - 1;

        // Start with all walkable
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                mapComp.setWalkable(x, y, true);
            }
        }

        // Create concentric ring walls with openings
        for (let ring = 3; ring < maxDist; ring += 3) {
            // Each ring has an opening at different angle
            const openingAngle = (ring * 0.5) % (Math.PI * 2);

            for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                // Skip opening area
                const angleDiff = Math.abs(((angle - openingAngle + Math.PI) % (Math.PI * 2)) - Math.PI);
                if (angleDiff > 0.5) {
                    const x = Math.round(cx + Math.cos(angle) * ring);
                    const y = Math.round(cy + Math.sin(angle) * ring);
                    if (x >= 0 && x < w && y >= 0 && y < h) {
                        mapComp.setWalkable(x, y, false);
                    }
                }
            }
        }
    }
}

// ============================================
// Initialize
// ============================================

Core.create({ debug: false });
const demoScene = new AStarDemoScene();
Core.setScene(demoScene);

// Expose scene for DemoPlayground scene switching
window.__demoScene = demoScene;

let lastTime = performance.now();

function gameLoop() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    Core.update(dt);
    requestAnimationFrame(gameLoop);
}

gameLoop();`;

This is an interactive A* grid pathfinding demo implemented with **ECS architecture**.

Click **Run** to start the simulation, use toolbar to switch map scenes, adjust parameters to observe pathfinding effects.

<DemoPlayground
    client:load
    title="A* Pathfinding - ECS Architecture"
    code={astarDemoCode}
    canvasWidth={580}
    canvasHeight={380}
    scenes={astarScenes}
    params={astarParams}
/>

<script is:inline src="/esengine/js/esengine.iife.js"></script>

## Scene Descriptions

- **Maze** - Maze generated using recursive division, tests long path finding
- **Random Obstacles** - Randomly distributed obstacles with adjustable density
- **Rooms** - Simulates room layouts, tests doors and corridors
- **Spiral** - Spiral-shaped obstacles, tests complex paths

## Related Documentation

- [Pathfinding System API](/esengine/en/modules/pathfinding) - Complete API documentation and usage guide
- [ORCA Local Avoidance](/esengine/en/modules/pathfinding/local-avoidance) - Multi-agent avoidance
- [Getting Started](/esengine/en/guide/getting-started) - ECS framework introduction
