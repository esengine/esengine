---
title: "ORCA Local Avoidance Demo"
description: "Interactive multi-agent collision avoidance demo using ECS architecture"
---

import DemoPlayground from '../../../../components/DemoPlayground.vue';

export const orcaScenes = [
    { id: 'circle', label: '○', name: 'Circle Exchange' },
    { id: 'cross', label: '+', name: 'Cross Intersection' },
    { id: 'funnel', label: '▷', name: 'Funnel' },
    { id: 'random', label: '✦', name: 'Random' }
];

export const orcaParams = [
    { id: 'agentCount', label: 'Agents', desc: 'Number of agents, more = heavier computation', value: 40, min: 10, max: 500, step: 10 },
    { id: 'maxSpeed', label: 'Speed', desc: 'Maximum movement speed', value: 90, min: 30, max: 150, step: 10 },
    { id: 'radius', label: 'Radius', desc: 'Collision radius, affects avoidance distance', value: 3, min: 3, max: 15, step: 1 },
    { id: 'neighborDist', label: 'Neighbor', desc: 'Neighbor detection range, larger = earlier avoidance', value: 70, min: 30, max: 120, step: 10 }
];

export const orcaDemoCode = `// ORCA Local Avoidance - ECS Architecture Demo
// ============================================
// Use toolbar buttons to switch scenes, use parameter panel to adjust settings
// Left-click canvas to add agent, right-click to place obstacle

const {
    Core, Scene, Component, EntitySystem, Matcher, Time,
    ECSComponent, ECSSystem,
    AvoidanceAgentComponent, AvoidanceWorldComponent, LocalAvoidanceSystem
} = ESEngine;

const WIDTH = 580, HEIGHT = 380;
const CX = WIDTH / 2, CY = HEIGHT / 2;

// Get parameters from external (passed by DemoPlayground)
const params = window.__demoParams || {
    agentCount: 40, maxSpeed: 90, radius: 3, neighborDist: 70
};

// Avoidance world component reference (for adding obstacles)
let worldComponent: any = null;

// ============================================
// Component Definitions
// ============================================

@ECSComponent('AgentTarget')
class AgentTargetComponent extends Component {
    targetX = 0;
    targetY = 0;
    color = '#00d4ff';
}

// ============================================
// System Definitions
// ============================================

@ECSSystem('TargetFollow', { updateOrder: 40 })
class TargetFollowSystem extends EntitySystem {
    constructor() {
        super(Matcher.all(AvoidanceAgentComponent, AgentTargetComponent));
    }
    process(entities) {
        for (const entity of entities) {
            const avoid = entity.getComponent(AvoidanceAgentComponent);
            const target = entity.getComponent(AgentTargetComponent);
            avoid.setPreferredVelocityTowards(target.targetX, target.targetY);
        }
    }
}

@ECSSystem('Movement', { updateOrder: 60 })
class MovementSystem extends EntitySystem {
    constructor() { super(Matcher.all(AvoidanceAgentComponent)); }
    process(entities) {
        const dt = Time.deltaTime;
        for (const entity of entities) {
            const a = entity.getComponent(AvoidanceAgentComponent);
            a.positionX += a.velocityX * dt;
            a.positionY += a.velocityY * dt;
            // Boundary bounce
            if (a.positionX < 10 || a.positionX > WIDTH - 10) a.velocityX *= -0.5;
            if (a.positionY < 10 || a.positionY > HEIGHT - 10) a.velocityY *= -0.5;
            a.positionX = Math.max(10, Math.min(WIDTH - 10, a.positionX));
            a.positionY = Math.max(10, Math.min(HEIGHT - 10, a.positionY));
        }
    }
}

@ECSSystem('Render', { updateOrder: 100 })
class RenderSystem extends EntitySystem {
    ctx: CanvasRenderingContext2D;
    fps = 0; frameCount = 0; lastFpsTime = 0;

    constructor(context: CanvasRenderingContext2D) {
        super(Matcher.all(AvoidanceAgentComponent, AgentTargetComponent));
        this.ctx = context;
    }

    process(entities) {
        // Motion blur effect
        this.ctx.fillStyle = 'rgba(22, 33, 62, 0.3)';
        this.ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // Draw obstacles
        this.ctx.fillStyle = '#2d4263';
        if (worldComponent) {
            for (const obs of worldComponent.obstacles) {
                // Obstacles stored as vertex lists, draw as polygons
                const v = obs.vertices;
                if (v.length >= 3) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(v[0].x, v[0].y);
                    for (let i = 1; i < v.length; i++) {
                        this.ctx.lineTo(v[i].x, v[i].y);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
        }

        // FPS calculation
        this.frameCount++;
        const now = performance.now();
        if (now - this.lastFpsTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastFpsTime = now;
        }

        // Draw agents
        for (const entity of entities) {
            const a = entity.getComponent(AvoidanceAgentComponent);
            const t = entity.getComponent(AgentTargetComponent);
            const x = a.positionX, y = a.positionY;

            // Target point
            this.ctx.beginPath();
            this.ctx.arc(t.targetX, t.targetY, 3, 0, Math.PI * 2);
            this.ctx.fillStyle = 'rgba(255,71,87,0.4)';
            this.ctx.fill();

            // Agent glow
            const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, a.radius * 2);
            gradient.addColorStop(0, t.color);
            gradient.addColorStop(1, 'transparent');
            this.ctx.beginPath();
            this.ctx.arc(x, y, a.radius * 2, 0, Math.PI * 2);
            this.ctx.fillStyle = gradient;
            this.ctx.fill();

            // Agent circle
            this.ctx.beginPath();
            this.ctx.arc(x, y, a.radius, 0, Math.PI * 2);
            this.ctx.fillStyle = t.color;
            this.ctx.fill();

            // Velocity direction
            const speed = Math.sqrt(a.velocityX ** 2 + a.velocityY ** 2);
            if (speed > 1) {
                const vx = a.velocityX / speed, vy = a.velocityY / speed;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x + vx * a.radius * 1.8, y + vy * a.radius * 1.8);
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }
        }

        // HUD
        this.ctx.fillStyle = 'rgba(0,0,0,0.6)';
        this.ctx.fillRect(5, 5, 150, 58);
        this.ctx.fillStyle = '#00d4ff';
        this.ctx.font = '11px monospace';
        this.ctx.fillText(\`Agents: \${entities.length}\`, 10, 20);
        this.ctx.fillText(\`Obstacles: \${worldComponent?.obstacles.length || 0}\`, 10, 32);
        this.ctx.fillText(\`FPS: \${this.fps}\`, 10, 44);
        this.ctx.fillStyle = '#888';
        this.ctx.fillText('Left:Add Right:Obstacle', 10, 55);
    }
}

// ============================================
// Scene
// ============================================

class ORCADemoScene extends Scene {
    worldEntity: any = null;

    initialize() {
        this.name = 'ORCADemo';

        // Create avoidance world entity first (must be before addSystem so LocalAvoidanceSystem can find it)
        this.worldEntity = this.createEntity('AvoidanceWorld');
        worldComponent = this.worldEntity.addComponent(new AvoidanceWorldComponent());

        this.addSystem(new TargetFollowSystem());
        this.addSystem(new LocalAvoidanceSystem());
        this.addSystem(new MovementSystem());
        this.addSystem(new RenderSystem(ctx));
    }

    onStart() {
        this.loadScenario('circle');
    }

    loadScenario(type: string) {
        console.log('loadScenario called:', type);

        // Clear existing agent entities
        const result = this.queryAll(AvoidanceAgentComponent);
        this.destroyEntities([...result.entities]);

        // Clear obstacles
        if (worldComponent) {
            worldComponent.clearObstacles();
        }

        const count = params.agentCount;
        const configs = {
            circle: () => {
                const r = 150;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    this.createAgent(
                        CX + Math.cos(angle) * r, CY + Math.sin(angle) * r,
                        CX - Math.cos(angle) * r, CY - Math.sin(angle) * r,
                        \`hsl(\${(i / count) * 360}, 80%, 60%)\`
                    );
                }
            },
            cross: () => {
                const n = Math.floor(count / 4);
                for (let i = 0; i < n; i++) {
                    this.createAgent(30, 80 + i * 12, WIDTH - 30, 80 + i * 12, '#00d4ff');
                    this.createAgent(WIDTH - 30, HEIGHT - 80 - i * 12, 30, HEIGHT - 80 - i * 12, '#ff6b6b');
                    this.createAgent(150 + i * 12, 30, 150 + i * 12, HEIGHT - 30, '#4ecdc4');
                    this.createAgent(WIDTH - 150 - i * 12, HEIGHT - 30, WIDTH - 150 - i * 12, 30, '#ffe66d');
                }
            },
            funnel: () => {
                for (let i = 0; i < count; i++) {
                    this.createAgent(
                        30 + Math.random() * 100, 50 + Math.random() * (HEIGHT - 100),
                        WIDTH - 30, CY,
                        \`hsl(\${180 + Math.random() * 60}, 80%, 60%)\`
                    );
                }
            },
            random: () => {
                for (let i = 0; i < count; i++) {
                    this.createAgent(
                        30 + Math.random() * (WIDTH - 60), 30 + Math.random() * (HEIGHT - 60),
                        30 + Math.random() * (WIDTH - 60), 30 + Math.random() * (HEIGHT - 60),
                        \`hsl(\${Math.random() * 360}, 70%, 60%)\`
                    );
                }
            }
        };
        configs[type]?.();
    }

    createAgent(x: number, y: number, tx: number, ty: number, color: string) {
        const entity = this.createEntity('Agent');
        const avoid = entity.addComponent(new AvoidanceAgentComponent());
        avoid.setPosition(x, y);
        avoid.radius = params.radius;
        avoid.maxSpeed = params.maxSpeed;
        avoid.neighborDist = params.neighborDist;
        avoid.timeHorizon = 2;
        avoid.autoApplyVelocity = true;

        const target = entity.addComponent(new AgentTargetComponent());
        target.targetX = tx;
        target.targetY = ty;
        target.color = color;
    }
}

// ============================================
// Initialize
// ============================================

Core.create({ debug: false });
const demoScene = new ORCADemoScene();
Core.setScene(demoScene);

// Expose scene for DemoPlayground
window.__demoScene = demoScene;

// Mouse event handling
canvas.addEventListener('click', (e: MouseEvent) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    // Left click adds agent
    const color = \`hsl(\${Math.random() * 360}, 80%, 60%)\`;
    demoScene.createAgent(x, y, CX + (Math.random() - 0.5) * 200, CY + (Math.random() - 0.5) * 200, color);
});

canvas.addEventListener('contextmenu', (e: MouseEvent) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    // Right click adds obstacle to AvoidanceWorldComponent
    // ORCA uses math coords (Y up), so screen CW order = math CCW
    // Order: top-left → top-right → bottom-right → bottom-left
    if (worldComponent) {
        worldComponent.addObstacle({
            vertices: [
                { x: x - 15, y: y - 15 },  // top-left
                { x: x + 15, y: y - 15 },  // top-right
                { x: x + 15, y: y + 15 },  // bottom-right
                { x: x - 15, y: y + 15 }   // bottom-left
            ]
        });
    }
});

let lastTime = performance.now();
let animationId: number;

function gameLoop() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    Core.update(dt);
    animationId = requestAnimationFrame(gameLoop);
}

gameLoop();`;

This is an interactive demo showcasing the ORCA (Optimal Reciprocal Collision Avoidance) algorithm, implemented with **ECS architecture**.

Click **Run** to start the simulation. Use toolbar buttons to switch scenes and adjust parameters to observe different behaviors.

**Interactive Controls:**
- **Left-click** on canvas to add new agent
- **Right-click** on canvas to place obstacle

<DemoPlayground
    client:load
    title="ORCA Local Avoidance - ECS Architecture"
    code={orcaDemoCode}
    canvasWidth={580}
    canvasHeight={380}
    scenes={orcaScenes}
    params={orcaParams}
/>

<script is:inline src="/esengine/js/esengine.iife.js"></script>

## Related Documentation

- [ORCA Local Avoidance API](/esengine/en/modules/pathfinding/local-avoidance) - Complete API documentation and usage guide
- [Pathfinding System](/esengine/en/modules/pathfinding) - Pathfinding module overview
- [Getting Started](/esengine/en/guide/getting-started) - ECS framework introduction
