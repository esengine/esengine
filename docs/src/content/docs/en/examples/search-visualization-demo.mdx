---
title: "A* Search Visualization"
description: "Visualize the A* algorithm search process to understand heuristic search principles"
---

import DemoPlayground from '../../../../components/DemoPlayground.vue';

export const vizScenes = [
    { id: 'simple', label: 'â—‹', name: 'Simple Path' },
    { id: 'obstacle', label: 'â¬›', name: 'Obstacle' },
    { id: 'maze', label: 'â¬œ', name: 'Maze' },
    { id: 'deadend', label: 'âœ•', name: 'Dead End Test' }
];

export const vizParams = [
    { id: 'gridSize', label: 'Grid', desc: 'Grid size', value: 25, min: 15, max: 40, step: 5 },
    { id: 'speed', label: 'Speed', desc: 'Search speed (steps/frame)', value: 3, min: 1, max: 20, step: 1 },
    { id: 'diagonal', label: 'Diagonal', desc: 'Diagonal movement (0=no, 1=yes)', value: 1, min: 0, max: 1, step: 1 }
];

export const vizDemoCode = `// A* Search Visualization - Understanding Heuristic Search
// ============================================
// Observe Open Set (frontier) and Closed Set (explored) changes

const { createGridMap } = ESEngine;

const WIDTH = 580, HEIGHT = 380;

const params = window.__demoParams || {
    gridSize: 25, speed: 3, diagonal: 1
};

// Local heuristic functions
function manhattanDist(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function octileDist(a, b) {
    const dx = Math.abs(a.x - b.x);
    const dy = Math.abs(a.y - b.y);
    return dx + dy + (1.414 - 2) * Math.min(dx, dy);
}

let gridMap = null;
let gridWidth = 25, gridHeight = 16;
let startPos = { x: 2, y: 2 };
let endPos = { x: 0, y: 0 };

// Search state
let searchState = {
    running: false,
    completed: false,
    found: false,
    openSet: new Map(),      // key -> { x, y, g, h, f, parent }
    closedSet: new Set(),    // key strings
    path: [],
    currentBest: null,
    nodesSearched: 0,
    startTime: 0,
    endTime: 0
};

// ============================================
// Visualization A* Implementation
// ============================================

function nodeKey(x, y) {
    return x + ',' + y;
}

function initSearch() {
    const h = params.diagonal === 1
        ? octileDist(startPos, endPos)
        : manhattanDist(startPos, endPos);

    searchState = {
        running: true,
        completed: false,
        found: false,
        openSet: new Map(),
        closedSet: new Set(),
        path: [],
        currentBest: null,
        nodesSearched: 0,
        startTime: performance.now(),
        endTime: 0
    };

    searchState.openSet.set(nodeKey(startPos.x, startPos.y), {
        x: startPos.x,
        y: startPos.y,
        g: 0,
        h: h,
        f: h,
        parent: null
    });
}

function stepSearch() {
    if (!searchState.running || searchState.completed) return;

    const { openSet, closedSet } = searchState;

    if (openSet.size === 0) {
        searchState.completed = true;
        searchState.running = false;
        searchState.found = false;
        searchState.endTime = performance.now();
        return;
    }

    // Find node with minimum f value
    let bestKey = null;
    let bestNode = null;
    for (const [key, node] of openSet) {
        if (!bestNode || node.f < bestNode.f || (node.f === bestNode.f && node.h < bestNode.h)) {
            bestKey = key;
            bestNode = node;
        }
    }

    searchState.currentBest = bestNode;
    searchState.nodesSearched++;

    // Check if reached goal
    if (bestNode.x === endPos.x && bestNode.y === endPos.y) {
        searchState.completed = true;
        searchState.running = false;
        searchState.found = true;
        searchState.endTime = performance.now();

        // Reconstruct path
        const path = [];
        let current = bestNode;
        while (current) {
            path.unshift({ x: current.x, y: current.y });
            current = current.parent;
        }
        searchState.path = path;
        return;
    }

    // Move from open to closed set
    openSet.delete(bestKey);
    closedSet.add(bestKey);

    // Expand neighbors
    const neighbors = getNeighbors(bestNode.x, bestNode.y);
    for (const neighbor of neighbors) {
        const key = nodeKey(neighbor.x, neighbor.y);

        if (closedSet.has(key)) continue;
        if (!gridMap.isWalkable(neighbor.x, neighbor.y)) continue;

        const tentativeG = bestNode.g + neighbor.cost;

        const existing = openSet.get(key);
        if (existing && tentativeG >= existing.g) continue;

        const h = params.diagonal === 1
            ? octileDist(neighbor, endPos)
            : manhattanDist(neighbor, endPos);

        const newNode = {
            x: neighbor.x,
            y: neighbor.y,
            g: tentativeG,
            h: h,
            f: tentativeG + h,
            parent: bestNode
        };

        openSet.set(key, newNode);
    }
}

function getNeighbors(x, y) {
    const neighbors = [];
    const dirs4 = [[0, -1], [1, 0], [0, 1], [-1, 0]];
    const dirs8 = [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1]];
    const dirs = params.diagonal === 1 ? dirs8 : dirs4;

    for (let i = 0; i < dirs.length; i++) {
        const [dx, dy] = dirs[i];
        const nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
            const cost = (dx !== 0 && dy !== 0) ? 1.414 : 1;
            neighbors.push({ x: nx, y: ny, cost });
        }
    }
    return neighbors;
}

// ============================================
// Rendering
// ============================================

function render(ctx) {
    if (!gridMap) return;

    const cellW = WIDTH / gridWidth;
    const cellH = HEIGHT / gridHeight;

    // Clear screen
    ctx.fillStyle = '#16213e';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Draw obstacles (first, as background)
    ctx.fillStyle = '#2d4263';
    for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
            if (!gridMap.isWalkable(x, y)) {
                ctx.fillRect(x * cellW, y * cellH, cellW - 1, cellH - 1);
            }
        }
    }

    // Draw Closed Set (explored)
    ctx.fillStyle = 'rgba(100, 100, 150, 0.6)';
    for (const key of searchState.closedSet) {
        const [x, y] = key.split(',').map(Number);
        ctx.fillRect(x * cellW + 1, y * cellH + 1, cellW - 2, cellH - 2);
    }

    // Draw Open Set (frontier)
    for (const [key, node] of searchState.openSet) {
        // Color intensity based on f value
        const intensity = Math.max(0.3, 1 - node.f / 100);
        ctx.fillStyle = \`rgba(0, 200, 255, \${intensity * 0.7})\`;
        ctx.fillRect(node.x * cellW + 1, node.y * cellH + 1, cellW - 2, cellH - 2);
    }

    // Draw final path
    if (searchState.path.length > 0) {
        ctx.strokeStyle = '#4ecdc4';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(searchState.path[0].x * cellW + cellW/2, searchState.path[0].y * cellH + cellH/2);
        for (let i = 1; i < searchState.path.length; i++) {
            ctx.lineTo(searchState.path[i].x * cellW + cellW/2, searchState.path[i].y * cellH + cellH/2);
        }
        ctx.stroke();
    }

    // Current best path to start
    if (searchState.currentBest && !searchState.completed) {
        ctx.strokeStyle = 'rgba(255, 230, 109, 0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        let node = searchState.currentBest;
        ctx.moveTo(node.x * cellW + cellW/2, node.y * cellH + cellH/2);
        while (node.parent) {
            node = node.parent;
            ctx.lineTo(node.x * cellW + cellW/2, node.y * cellH + cellH/2);
        }
        ctx.stroke();
    }

    // Draw grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    for (let x = 0; x <= gridWidth; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellW, 0);
        ctx.lineTo(x * cellW, HEIGHT);
        ctx.stroke();
    }
    for (let y = 0; y <= gridHeight; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellH);
        ctx.lineTo(WIDTH, y * cellH);
        ctx.stroke();
    }

    // Draw start
    ctx.fillStyle = '#00d4ff';
    ctx.beginPath();
    ctx.arc(startPos.x * cellW + cellW/2, startPos.y * cellH + cellH/2, Math.min(cellW, cellH) * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // Draw end
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(endPos.x * cellW + cellW/2, endPos.y * cellH + cellH/2, Math.min(cellW, cellH) * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // HUD
    const panelX = 5, panelY = 5;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(panelX, panelY, 175, 100);

    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText('A* Search Visualization', panelX + 5, panelY + 15);

    ctx.font = '10px monospace';
    ctx.fillStyle = '#00d4ff';
    ctx.fillText(\`Open Set:   \${searchState.openSet.size}\`, panelX + 5, panelY + 32);
    ctx.fillStyle = 'rgba(150, 150, 200, 1)';
    ctx.fillText(\`Closed Set: \${searchState.closedSet.size}\`, panelX + 5, panelY + 45);
    ctx.fillStyle = '#ffe66d';
    ctx.fillText(\`Nodes:      \${searchState.nodesSearched}\`, panelX + 5, panelY + 58);

    if (searchState.completed) {
        const time = (searchState.endTime - searchState.startTime).toFixed(2);
        ctx.fillStyle = searchState.found ? '#4ecdc4' : '#ff6b6b';
        ctx.fillText(searchState.found ? \`Path found! \${searchState.path.length} nodes\` : 'No path found!', panelX + 5, panelY + 73);
        ctx.fillStyle = '#888';
        ctx.fillText(\`Time: \${time}ms\`, panelX + 5, panelY + 86);
    } else if (searchState.running) {
        ctx.fillStyle = '#4ecdc4';
        ctx.fillText('Searching...', panelX + 5, panelY + 73);
    } else {
        ctx.fillStyle = '#888';
        ctx.fillText('Click to set start/end', panelX + 5, panelY + 73);
    }

    // Legend
    const legendX = WIDTH - 120, legendY = 5;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(legendX, legendY, 115, 70);
    ctx.font = '9px monospace';

    ctx.fillStyle = 'rgba(0, 200, 255, 0.6)';
    ctx.fillRect(legendX + 5, legendY + 8, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Open (frontier)', legendX + 22, legendY + 18);

    ctx.fillStyle = 'rgba(100, 100, 150, 0.5)';
    ctx.fillRect(legendX + 5, legendY + 25, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Closed (explored)', legendX + 22, legendY + 35);

    ctx.fillStyle = '#ffe66d';
    ctx.fillRect(legendX + 5, legendY + 42, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Current path', legendX + 22, legendY + 52);

    ctx.fillStyle = '#4ecdc4';
    ctx.fillRect(legendX + 5, legendY + 59, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Final path', legendX + 22, legendY + 69);
}

// ============================================
// Map Generation
// ============================================

function generateMap(type) {
    gridWidth = params.gridSize;
    gridHeight = Math.floor(gridWidth * HEIGHT / WIDTH);

    gridMap = createGridMap(gridWidth, gridHeight);

    // Reset search state
    searchState = {
        running: false,
        completed: false,
        found: false,
        openSet: new Map(),
        closedSet: new Set(),
        path: [],
        currentBest: null,
        nodesSearched: 0,
        startTime: 0,
        endTime: 0
    };

    const w = gridWidth, h = gridHeight;

    const generators = {
        simple: () => {
            // Empty map, simple path
            startPos = { x: 2, y: Math.floor(h / 2) };
            endPos = { x: w - 3, y: Math.floor(h / 2) };
        },
        obstacle: () => {
            // Obstacle in the middle
            const midX = Math.floor(w / 2);
            for (let y = 3; y < h - 3; y++) {
                gridMap.setWalkable(midX, y, false);
            }
            startPos = { x: 3, y: Math.floor(h / 2) };
            endPos = { x: w - 4, y: Math.floor(h / 2) };
        },
        maze: () => {
            // Simple maze
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    gridMap.setWalkable(x, y, false);
                }
            }
            const carve = (x, y) => {
                gridMap.setWalkable(x, y, true);
                const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(() => Math.random() - 0.5);
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < w-1 && ny > 0 && ny < h-1 && !gridMap.isWalkable(nx, ny)) {
                        gridMap.setWalkable(x + dx/2, y + dy/2, true);
                        carve(nx, ny);
                    }
                }
            };
            carve(1, 1);
            startPos = { x: 1, y: 1 };
            endPos = findWalkable(w - 2, h - 2);
        },
        deadend: () => {
            // Dead end test (goal is surrounded)
            const cx = Math.floor(w / 2);
            const cy = Math.floor(h / 2);
            // Walls
            for (let x = cx - 3; x <= cx + 3; x++) {
                gridMap.setWalkable(x, cy - 3, false);
                gridMap.setWalkable(x, cy + 3, false);
            }
            for (let y = cy - 3; y <= cy + 3; y++) {
                gridMap.setWalkable(cx - 3, y, false);
                gridMap.setWalkable(cx + 3, y, false);
            }
            startPos = { x: 2, y: 2 };
            endPos = { x: cx, y: cy };
        }
    };

    generators[type]?.();
}

function findWalkable(px, py) {
    if (gridMap.isWalkable(px, py)) return { x: px, y: py };
    for (let r = 1; r < 20; r++) {
        for (let dx = -r; dx <= r; dx++) {
            for (let dy = -r; dy <= r; dy++) {
                const x = px + dx, y = py + dy;
                if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                    if (gridMap.isWalkable(x, y)) return { x, y };
                }
            }
        }
    }
    return { x: 1, y: 1 };
}

// ============================================
// Initialize
// ============================================

generateMap('simple');
initSearch();  // Auto-start search

// Click to set start/end and begin search
let clickMode = 'start';
canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const cellW = WIDTH / gridWidth;
    const cellH = HEIGHT / gridHeight;
    const gx = Math.floor(mx / cellW);
    const gy = Math.floor(my / cellH);

    if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight && gridMap.isWalkable(gx, gy)) {
        if (clickMode === 'start') {
            startPos = { x: gx, y: gy };
            clickMode = 'end';
        } else {
            endPos = { x: gx, y: gy };
            clickMode = 'start';
            // Start search
            initSearch();
        }
    }
});

// Scene switching
window.__demoScene = {
    loadScenario: (type) => {
        generateMap(type);
        initSearch();
    }
};

// Game loop
function gameLoop() {
    // Execute multiple search steps per frame
    if (searchState.running) {
        for (let i = 0; i < params.speed; i++) {
            stepSearch();
        }
    }

    render(ctx);
    requestAnimationFrame(gameLoop);
}

gameLoop();`;

This is an **A* Search Visualization Demo** to help understand how heuristic search algorithms work.

Click **Run** to start, then click on the map to set start and end points.

**Color Legend:**
- ðŸŸ¦ **Blue** - Open Set (frontier nodes to be explored)
- ðŸŸ« **Gray-purple** - Closed Set (already explored nodes)
- ðŸŸ¨ **Yellow line** - Current best path
- ðŸŸ© **Cyan line** - Final path

<DemoPlayground
    client:load
    title="A* Search Visualization"
    code={vizDemoCode}
    canvasWidth={580}
    canvasHeight={380}
    scenes={vizScenes}
    params={vizParams}
/>

<script is:inline src="/esengine/js/esengine.iife.js"></script>

## A* Algorithm Principles

A* algorithm maintains two sets to search for the shortest path:

| Set | Purpose |
|-----|---------|
| **Open Set** | Discovered but unexplored nodes (search frontier) |
| **Closed Set** | Fully explored nodes |

Each iteration expands the node with minimum **f(n) = g(n) + h(n)** from the Open Set:
- **g(n)** - Actual cost from start to current node
- **h(n)** - Heuristic estimate from current node to goal

## Scene Descriptions

- **Simple Path** - No obstacles, observe how the algorithm "heads straight" to the goal
- **Obstacle** - See how the algorithm adjusts direction when encountering obstacles
- **Maze** - Search behavior in complex environments
- **Dead End Test** - Goal is surrounded, observe the algorithm exploring the entire reachable area

## Related Documentation

- [Algorithm Comparison Demo](/esengine/en/examples/algorithm-comparison-demo) - Compare different algorithms
- [Pathfinding System API](/esengine/en/modules/pathfinding) - Complete documentation
