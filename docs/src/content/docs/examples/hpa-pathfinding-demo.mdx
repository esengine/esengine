---
title: "HPA* 分层寻路"
description: "分层寻路 A* (Hierarchical Pathfinding A*) 演示，适用于超大地图"
---

import DemoPlayground from '../../../components/DemoPlayground.vue';

export const hpaScenes = [
    { id: 'small', label: 'S', name: '小地图 (100x65)' },
    { id: 'medium', label: 'M', name: '中地图 (250x163)' },
    { id: 'large', label: 'L', name: '大地图 (500x325)' },
    { id: 'huge', label: 'XL', name: '超大地图 (1000x650)' }
];

export const hpaParams = [
    { id: 'clusterSize', label: 'Cluster', desc: '集群大小（边长）', value: 64, min: 10, max: 100, step: 10 },
    { id: 'obstacleRate', label: 'Obstacles', desc: '障碍物密度（%）', value: 15, min: 0, max: 100, step: 1 },
    { id: 'showClusters', label: 'Clusters', desc: '显示集群边界（0=否，1=是）', value: 1, min: 0, max: 1, step: 1 }
];

export const hpaDemoCode = `// HPA* 分层寻路演示
// ============================================
// 对比 HPA* 与标准 A* 在超大地图上的性能差异

const {
    GridMap, createGridMap,
    AStarPathfinder, HPAPathfinder,
    octileDistance
} = ESEngine;

const WIDTH = 580, HEIGHT = 380;

const params = window.__demoParams || {
    clusterSize: 20, obstacleRate: 15, showClusters: 1
};

let gridMap = null;
let mapWidth = 100, mapHeight = 65;
let startPos = { x: 5, y: 5 };
let endPos = { x: 0, y: 0 };

// 性能结果
let results = {
    astar: { time: 0, nodes: 0, pathLen: 0, path: [] },
    hpa: { time: 0, nodes: 0, pathLen: 0, path: [], stats: null, preprocessTime: 0, cachedTime: 0 }
};

let hpaPathfinder = null;
let isSearching = false;

// ============================================
// 渲染
// ============================================

function render(ctx) {
    if (!gridMap) return;

    const cellW = WIDTH / mapWidth;
    const cellH = HEIGHT / mapHeight;
    const drawCells = cellW >= 2;  // 只有当单元格足够大时才绘制

    // 清屏
    ctx.fillStyle = '#16213e';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // 绘制集群边界
    if (params.showClusters === 1) {
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
        ctx.lineWidth = 1;
        const cs = params.clusterSize;
        for (let cx = 0; cx <= Math.ceil(mapWidth / cs); cx++) {
            const x = cx * cs * cellW;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, HEIGHT);
            ctx.stroke();
        }
        for (let cy = 0; cy <= Math.ceil(mapHeight / cs); cy++) {
            const y = cy * cs * cellH;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(WIDTH, y);
            ctx.stroke();
        }
    }

    // 绘制障碍物（仅当单元格足够大时）
    if (drawCells) {
        ctx.fillStyle = '#2d4263';
        for (let y = 0; y < mapHeight; y++) {
            for (let x = 0; x < mapWidth; x++) {
                if (!gridMap.isWalkable(x, y)) {
                    ctx.fillRect(x * cellW, y * cellH, cellW - 0.5, cellH - 0.5);
                }
            }
        }
    } else {
        // 大地图：使用采样绘制
        ctx.fillStyle = '#2d4263';
        const sampleRate = Math.ceil(mapWidth / WIDTH * 2);
        for (let sy = 0; sy < HEIGHT; sy += 2) {
            for (let sx = 0; sx < WIDTH; sx += 2) {
                const gx = Math.floor(sx / cellW);
                const gy = Math.floor(sy / cellH);
                if (gx < mapWidth && gy < mapHeight && !gridMap.isWalkable(gx, gy)) {
                    ctx.fillRect(sx, sy, 2, 2);
                }
            }
        }
    }

    // 绘制 A* 路径
    if (results.astar.path.length > 1) {
        ctx.strokeStyle = 'rgba(255, 107, 107, 0.7)';
        ctx.lineWidth = drawCells ? 2 : 3;
        ctx.beginPath();
        ctx.moveTo(results.astar.path[0].x * cellW + cellW/2, results.astar.path[0].y * cellH + cellH/2);
        for (let i = 1; i < results.astar.path.length; i++) {
            ctx.lineTo(results.astar.path[i].x * cellW + cellW/2, results.astar.path[i].y * cellH + cellH/2);
        }
        ctx.stroke();
    }

    // 绘制 HPA* 路径
    if (results.hpa.path.length > 1) {
        ctx.strokeStyle = 'rgba(78, 205, 196, 0.9)';
        ctx.lineWidth = drawCells ? 3 : 4;
        ctx.beginPath();
        ctx.moveTo(results.hpa.path[0].x * cellW + cellW/2, results.hpa.path[0].y * cellH + cellH/2);
        for (let i = 1; i < results.hpa.path.length; i++) {
            ctx.lineTo(results.hpa.path[i].x * cellW + cellW/2, results.hpa.path[i].y * cellH + cellH/2);
        }
        ctx.stroke();
    }

    // 绘制起点终点
    const pointSize = Math.max(4, Math.min(cellW, cellH) * 0.5);
    ctx.fillStyle = '#00d4ff';
    ctx.beginPath();
    ctx.arc(startPos.x * cellW + cellW/2, startPos.y * cellH + cellH/2, pointSize, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(endPos.x * cellW + cellW/2, endPos.y * cellH + cellH/2, pointSize, 0, Math.PI * 2);
    ctx.fill();

    // HUD - 性能对比
    const panelX = 5, panelY = 5;
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(panelX, panelY, 240, 155);

    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText('HPA* vs A* Performance', panelX + 5, panelY + 15);

    ctx.font = '10px monospace';
    ctx.fillStyle = '#888';
    const totalCells = (mapWidth * mapHeight / 1000).toFixed(0);
    ctx.fillText(\`Map: \${mapWidth}x\${mapHeight} (\${totalCells}K cells)\`, panelX + 5, panelY + 30);

    // A* 结果
    ctx.fillStyle = '#ff6b6b';
    ctx.fillText('Standard A*:', panelX + 5, panelY + 47);
    ctx.fillStyle = '#ccc';
    if (results.astar.time > 0) {
        ctx.fillText(\`  Time: \${results.astar.time.toFixed(2)}ms\`, panelX + 5, panelY + 60);
        ctx.fillText(\`  Nodes: \${results.astar.nodes.toLocaleString()}\`, panelX + 5, panelY + 72);
    } else {
        ctx.fillText('  (searching...)', panelX + 5, panelY + 60);
    }

    // HPA* 结果
    ctx.fillStyle = '#4ecdc4';
    ctx.fillText('HPA* (Lazy Intra-Edges):', panelX + 5, panelY + 87);
    ctx.fillStyle = '#ccc';
    if (results.hpa.time > 0) {
        ctx.fillText(\`  Preprocess: \${results.hpa.preprocessTime.toFixed(1)}ms\`, panelX + 5, panelY + 100);
        ctx.fillText(\`  1st Query: \${results.hpa.time.toFixed(2)}ms\`, panelX + 5, panelY + 112);
        if (results.hpa.cachedTime > 0) {
            ctx.fillText(\`  Cached: \${results.hpa.cachedTime.toFixed(2)}ms\`, panelX + 5, panelY + 124);
        }
        if (results.hpa.stats) {
            ctx.fillText(\`  Clusters: \${results.hpa.stats.clusters}, Nodes: \${results.hpa.stats.abstractNodes}\`, panelX + 5, panelY + 136);
        }
    } else {
        ctx.fillText('  (searching...)', panelX + 5, panelY + 100);
    }

    // 性能提升
    if (results.astar.time > 0 && results.hpa.cachedTime > 0) {
        const speedup = results.astar.time / results.hpa.cachedTime;
        ctx.fillStyle = speedup > 1 ? '#4ecdc4' : '#ff6b6b';
        ctx.font = 'bold 12px monospace';
        ctx.fillText(\`Speedup (cached): \${speedup.toFixed(0)}x\`, panelX + 5, panelY + 151);
    }

    // 图例
    const legendX = WIDTH - 90, legendY = 5;
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(legendX, legendY, 85, 55);
    ctx.font = '9px monospace';

    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(legendX + 5, legendY + 10, 15, 3);
    ctx.fillStyle = '#fff';
    ctx.fillText('A*', legendX + 25, legendY + 15);

    ctx.fillStyle = '#4ecdc4';
    ctx.fillRect(legendX + 5, legendY + 25, 15, 3);
    ctx.fillStyle = '#fff';
    ctx.fillText('HPA*', legendX + 25, legendY + 30);

    ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
    ctx.fillRect(legendX + 5, legendY + 40, 15, 3);
    ctx.fillStyle = '#fff';
    ctx.fillText('Cluster', legendX + 25, legendY + 45);

    // 大地图提示
    if (!drawCells) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(WIDTH/2 - 80, HEIGHT - 25, 160, 20);
        ctx.fillStyle = '#888';
        ctx.font = '10px monospace';
        ctx.fillText('Large map: simplified view', WIDTH/2 - 70, HEIGHT - 10);
    }
}

// ============================================
// 寻路
// ============================================

async function runPathfinding() {
    if (!gridMap || isSearching) return;
    isSearching = true;

    // 重置结果
    results.astar = { time: 0, nodes: 0, pathLen: 0, path: [] };
    results.hpa = { time: 0, nodes: 0, pathLen: 0, path: [], stats: null, preprocessTime: 0, cachedTime: 0 };

    // 根据地图大小调整 maxNodes，确保大地图能完整搜索
    const maxNodes = mapWidth * mapHeight;
    const options = { allowDiagonal: true, heuristic: octileDistance, maxNodes };

    // 延迟执行以显示 UI 更新
    await new Promise(r => setTimeout(r, 50));

    // 标准 A*
    const astar = new AStarPathfinder(gridMap);
    let t0 = performance.now();
    let result = astar.findPath(startPos.x, startPos.y, endPos.x, endPos.y, options);
    results.astar = {
        time: performance.now() - t0,
        nodes: result.nodesSearched,
        pathLen: result.path.length,
        path: result.path
    };

    await new Promise(r => setTimeout(r, 10));

    // HPA* with lazy intra-edges (default)
    hpaPathfinder = new HPAPathfinder(gridMap, {
        clusterSize: params.clusterSize,
        maxEntranceWidth: 16,
        cacheInternalPaths: true,
        lazyIntraEdges: true  // 延迟计算 intra-edges
    });

    // 预处理（现在非常快，因为不计算真实路径）
    t0 = performance.now();
    hpaPathfinder.preprocess();
    const preprocessTime = performance.now() - t0;

    // 第一次查询（会触发 lazy 路径计算）
    t0 = performance.now();
    result = hpaPathfinder.findPath(startPos.x, startPos.y, endPos.x, endPos.y, options);
    const firstQueryTime = performance.now() - t0;

    // 第二次查询（使用缓存，应该非常快）
    t0 = performance.now();
    hpaPathfinder.findPath(startPos.x, startPos.y, endPos.x, endPos.y, options);
    const cachedTime = performance.now() - t0;

    results.hpa = {
        time: firstQueryTime,
        nodes: result.nodesSearched,
        pathLen: result.path.length,
        path: result.path,
        stats: hpaPathfinder.getStats(),
        preprocessTime: preprocessTime,
        cachedTime: cachedTime
    };

    isSearching = false;
}

// ============================================
// 地图生成
// ============================================

function generateMap(size) {
    const sizes = {
        small: { w: 100, h: 65 },
        medium: { w: 250, h: 163 },
        large: { w: 500, h: 325 },
        huge: { w: 1000, h: 650 }
    };

    const s = sizes[size] || sizes.small;
    mapWidth = s.w;
    mapHeight = s.h;

    gridMap = createGridMap(mapWidth, mapHeight);
    hpaPathfinder = null;

    // 生成随机障碍
    const rate = params.obstacleRate / 100;
    for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
            if (Math.random() < rate) {
                gridMap.setWalkable(x, y, false);
            }
        }
    }

    // 确保起点和终点周围畅通
    const clearRadius = Math.max(3, Math.floor(Math.min(mapWidth, mapHeight) / 20));
    const clearArea = (cx, cy, r) => {
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                const x = cx + dx, y = cy + dy;
                if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
                    gridMap.setWalkable(x, y, true);
                }
            }
        }
    };

    startPos = { x: clearRadius + 2, y: clearRadius + 2 };
    endPos = { x: mapWidth - clearRadius - 3, y: mapHeight - clearRadius - 3 };
    clearArea(startPos.x, startPos.y, clearRadius);
    clearArea(endPos.x, endPos.y, clearRadius);

    // 重置结果
    results.astar = { time: 0, nodes: 0, pathLen: 0, path: [] };
    results.hpa = { time: 0, nodes: 0, pathLen: 0, path: [], stats: null, preprocessTime: 0, cachedTime: 0 };

    runPathfinding();
}

// ============================================
// 初始化
// ============================================

generateMap('small');

// 点击设置起点/终点
let clickMode = 'start';
canvas.addEventListener('click', (e) => {
    if (isSearching) return;

    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const cellW = WIDTH / mapWidth;
    const cellH = HEIGHT / mapHeight;
    const gx = Math.floor(mx / cellW);
    const gy = Math.floor(my / cellH);

    if (gx >= 0 && gx < mapWidth && gy >= 0 && gy < mapHeight && gridMap.isWalkable(gx, gy)) {
        if (clickMode === 'start') {
            startPos = { x: gx, y: gy };
            clickMode = 'end';
        } else {
            endPos = { x: gx, y: gy };
            clickMode = 'start';
            runPathfinding();
        }
    }
});

// 场景切换
window.__demoScene = {
    loadScenario: (type) => {
        generateMap(type);
    }
};

// 游戏循环
function gameLoop() {
    render(ctx);
    requestAnimationFrame(gameLoop);
}

gameLoop();`;

这是一个 **HPA* (分层寻路 A*)** 演示，展示在**超大地图**上的性能优势。

点击 **Run** 开始，使用工具栏切换不同地图大小，观察 HPA* 与标准 A* 的性能对比。

**HPA* 原理：**
1. 将地图划分为**集群 (Clusters)**
2. 在集群边界检测**入口点 (Entrances)**
3. 构建**抽象图**连接入口点
4. 先在抽象图上寻路，再细化为详细路径

**Lazy Intra-Edges 优化：**
- 预处理速度提升 ~1000 倍（1000x650 地图：52ms vs 68s）
- 首次查询按需计算实际路径
- 后续查询使用缓存路径（极快）

<DemoPlayground
    client:load
    title="HPA* 分层寻路 - 超大地图优化"
    code={hpaDemoCode}
    canvasWidth={580}
    canvasHeight={380}
    scenes={hpaScenes}
    params={hpaParams}
/>

<script is:inline src="/esengine/js/esengine.iife.js"></script>

## 性能对比

| 地图大小 | 单元格数 | A* 适用性 | HPA* 优势 |
|----------|----------|-----------|-----------|
| 100x65 | ~6,500 | ✅ 良好 | 轻微 |
| 250x163 | ~40,000 | ⚠️ 较慢 | 明显 |
| 500x325 | ~162,500 | ❌ 很慢 | **显著** |
| 1000x650 | ~650,000 | ❌ 极慢 | **巨大** |

## 适用场景

- **开放世界游戏** - 大型连续地图（如 1000x1000+）
- **RTS 游戏** - 需要频繁寻路的大量单位
- **城市模拟** - 复杂的道路网络
- **服务器端寻路** - 需要快速响应的后端

## 参数说明

| 参数 | 说明 |
|------|------|
| **Cluster** | 集群大小，越大预处理越快但精度降低 |
| **Obstacles** | 障碍物密度 |
| **Clusters** | 是否显示集群边界线 |

## 相关文档

- [算法对比演示](/esengine/examples/algorithm-comparison-demo) - 比较 A*、双向 A*、JPS
- [搜索可视化](/esengine/examples/search-visualization-demo) - A* 搜索过程可视化
- [寻路系统 API](/esengine/modules/pathfinding) - 完整文档
