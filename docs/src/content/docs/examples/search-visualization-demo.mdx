---
title: "A* æœç´¢å¯è§†åŒ–"
description: "å¯è§†åŒ– A* ç®—æ³•çš„æœç´¢è¿‡ç¨‹ï¼Œç†è§£å¯å‘å¼æœç´¢åŸç†"
---

import DemoPlayground from '../../../components/DemoPlayground.vue';

export const vizScenes = [
    { id: 'simple', label: 'â—‹', name: 'ç®€å•è·¯å¾„' },
    { id: 'obstacle', label: 'â¬›', name: 'ç»•è¿‡éšœç¢' },
    { id: 'maze', label: 'â¬œ', name: 'è¿·å®«' },
    { id: 'deadend', label: 'âœ•', name: 'æ­»è·¯æµ‹è¯•' }
];

export const vizParams = [
    { id: 'gridSize', label: 'Grid', desc: 'ç½‘æ ¼å¤§å°', value: 25, min: 15, max: 40, step: 5 },
    { id: 'speed', label: 'Speed', desc: 'æœç´¢é€Ÿåº¦ï¼ˆæ­¥/å¸§ï¼‰', value: 3, min: 1, max: 20, step: 1 },
    { id: 'diagonal', label: 'Diagonal', desc: 'å¯¹è§’ç§»åŠ¨ï¼ˆ0=å¦ï¼Œ1=æ˜¯ï¼‰', value: 1, min: 0, max: 1, step: 1 }
];

export const vizDemoCode = `// A* æœç´¢å¯è§†åŒ– - ç†è§£å¯å‘å¼æœç´¢
// ============================================
// è§‚å¯Ÿ Open Setï¼ˆå¾…æ¢ç´¢ï¼‰å’Œ Closed Setï¼ˆå·²æ¢ç´¢ï¼‰çš„å˜åŒ–

const { createGridMap } = ESEngine;

const WIDTH = 580, HEIGHT = 380;

const params = window.__demoParams || {
    gridSize: 25, speed: 3, diagonal: 1
};

// æœ¬åœ°å®ç°å¯å‘å¼å‡½æ•°
function manhattanDist(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function octileDist(a, b) {
    const dx = Math.abs(a.x - b.x);
    const dy = Math.abs(a.y - b.y);
    return dx + dy + (1.414 - 2) * Math.min(dx, dy);
}

let gridMap = null;
let gridWidth = 25, gridHeight = 16;
let startPos = { x: 2, y: 2 };
let endPos = { x: 0, y: 0 };

// æœç´¢çŠ¶æ€
let searchState = {
    running: false,
    completed: false,
    found: false,
    openSet: new Map(),      // key -> { x, y, g, h, f, parent }
    closedSet: new Set(),    // key strings
    path: [],
    currentBest: null,
    nodesSearched: 0,
    startTime: 0,
    endTime: 0
};

// ============================================
// å¯è§†åŒ– A* å®ç°
// ============================================

function nodeKey(x, y) {
    return x + ',' + y;
}

function initSearch() {
    const h = params.diagonal === 1
        ? octileDist(startPos, endPos)
        : manhattanDist(startPos, endPos);

    searchState = {
        running: true,
        completed: false,
        found: false,
        openSet: new Map(),
        closedSet: new Set(),
        path: [],
        currentBest: null,
        nodesSearched: 0,
        startTime: performance.now(),
        endTime: 0
    };

    searchState.openSet.set(nodeKey(startPos.x, startPos.y), {
        x: startPos.x,
        y: startPos.y,
        g: 0,
        h: h,
        f: h,
        parent: null
    });
}

function stepSearch() {
    if (!searchState.running || searchState.completed) return;

    const { openSet, closedSet } = searchState;

    if (openSet.size === 0) {
        searchState.completed = true;
        searchState.running = false;
        searchState.found = false;
        searchState.endTime = performance.now();
        return;
    }

    // æ‰¾åˆ° f å€¼æœ€å°çš„èŠ‚ç‚¹
    let bestKey = null;
    let bestNode = null;
    for (const [key, node] of openSet) {
        if (!bestNode || node.f < bestNode.f || (node.f === bestNode.f && node.h < bestNode.h)) {
            bestKey = key;
            bestNode = node;
        }
    }

    searchState.currentBest = bestNode;
    searchState.nodesSearched++;

    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
    if (bestNode.x === endPos.x && bestNode.y === endPos.y) {
        searchState.completed = true;
        searchState.running = false;
        searchState.found = true;
        searchState.endTime = performance.now();

        // å›æº¯è·¯å¾„
        const path = [];
        let current = bestNode;
        while (current) {
            path.unshift({ x: current.x, y: current.y });
            current = current.parent;
        }
        searchState.path = path;
        return;
    }

    // ä» open set ç§»åˆ° closed set
    openSet.delete(bestKey);
    closedSet.add(bestKey);

    // å±•å¼€é‚»å±…
    const neighbors = getNeighbors(bestNode.x, bestNode.y);
    for (const neighbor of neighbors) {
        const key = nodeKey(neighbor.x, neighbor.y);

        if (closedSet.has(key)) continue;
        if (!gridMap.isWalkable(neighbor.x, neighbor.y)) continue;

        const tentativeG = bestNode.g + neighbor.cost;

        const existing = openSet.get(key);
        if (existing && tentativeG >= existing.g) continue;

        const h = params.diagonal === 1
            ? octileDist(neighbor, endPos)
            : manhattanDist(neighbor, endPos);

        const newNode = {
            x: neighbor.x,
            y: neighbor.y,
            g: tentativeG,
            h: h,
            f: tentativeG + h,
            parent: bestNode
        };

        openSet.set(key, newNode);
    }
}

function getNeighbors(x, y) {
    const neighbors = [];
    const dirs4 = [[0, -1], [1, 0], [0, 1], [-1, 0]];
    const dirs8 = [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1]];
    const dirs = params.diagonal === 1 ? dirs8 : dirs4;

    for (let i = 0; i < dirs.length; i++) {
        const [dx, dy] = dirs[i];
        const nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
            const cost = (dx !== 0 && dy !== 0) ? 1.414 : 1;
            neighbors.push({ x: nx, y: ny, cost });
        }
    }
    return neighbors;
}

// ============================================
// æ¸²æŸ“
// ============================================

function render(ctx) {
    if (!gridMap) return;

    const cellW = WIDTH / gridWidth;
    const cellH = HEIGHT / gridHeight;

    // æ¸…å±
    ctx.fillStyle = '#16213e';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // ç»˜åˆ¶éšœç¢ç‰©ï¼ˆå…ˆç”»ï¼Œä½œä¸ºèƒŒæ™¯ï¼‰
    ctx.fillStyle = '#2d4263';
    for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
            if (!gridMap.isWalkable(x, y)) {
                ctx.fillRect(x * cellW, y * cellH, cellW - 1, cellH - 1);
            }
        }
    }

    // ç»˜åˆ¶ Closed Setï¼ˆå·²æ¢ç´¢ï¼‰
    ctx.fillStyle = 'rgba(100, 100, 150, 0.6)';
    for (const key of searchState.closedSet) {
        const [x, y] = key.split(',').map(Number);
        ctx.fillRect(x * cellW + 1, y * cellH + 1, cellW - 2, cellH - 2);
    }

    // ç»˜åˆ¶ Open Setï¼ˆå¾…æ¢ç´¢/è¾¹ç•Œï¼‰
    for (const [key, node] of searchState.openSet) {
        // ç”¨ f å€¼å†³å®šé¢œè‰²æ·±æµ…
        const intensity = Math.max(0.3, 1 - node.f / 100);
        ctx.fillStyle = \`rgba(0, 200, 255, \${intensity * 0.7})\`;
        ctx.fillRect(node.x * cellW + 1, node.y * cellH + 1, cellW - 2, cellH - 2);
    }

    // ç»˜åˆ¶è·¯å¾„
    if (searchState.path.length > 0) {
        ctx.strokeStyle = '#4ecdc4';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(searchState.path[0].x * cellW + cellW/2, searchState.path[0].y * cellH + cellH/2);
        for (let i = 1; i < searchState.path.length; i++) {
            ctx.lineTo(searchState.path[i].x * cellW + cellW/2, searchState.path[i].y * cellH + cellH/2);
        }
        ctx.stroke();
    }

    // å½“å‰æœ€ä½³èŠ‚ç‚¹åˆ°èµ·ç‚¹çš„è·¯å¾„
    if (searchState.currentBest && !searchState.completed) {
        ctx.strokeStyle = 'rgba(255, 230, 109, 0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        let node = searchState.currentBest;
        ctx.moveTo(node.x * cellW + cellW/2, node.y * cellH + cellH/2);
        while (node.parent) {
            node = node.parent;
            ctx.lineTo(node.x * cellW + cellW/2, node.y * cellH + cellH/2);
        }
        ctx.stroke();
    }

    // ç»˜åˆ¶ç½‘æ ¼çº¿
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    for (let x = 0; x <= gridWidth; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellW, 0);
        ctx.lineTo(x * cellW, HEIGHT);
        ctx.stroke();
    }
    for (let y = 0; y <= gridHeight; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellH);
        ctx.lineTo(WIDTH, y * cellH);
        ctx.stroke();
    }

    // ç»˜åˆ¶èµ·ç‚¹
    ctx.fillStyle = '#00d4ff';
    ctx.beginPath();
    ctx.arc(startPos.x * cellW + cellW/2, startPos.y * cellH + cellH/2, Math.min(cellW, cellH) * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // ç»˜åˆ¶ç»ˆç‚¹
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(endPos.x * cellW + cellW/2, endPos.y * cellH + cellH/2, Math.min(cellW, cellH) * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // HUD
    const panelX = 5, panelY = 5;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(panelX, panelY, 175, 100);

    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText('A* Search Visualization', panelX + 5, panelY + 15);

    ctx.font = '10px monospace';
    ctx.fillStyle = '#00d4ff';
    ctx.fillText(\`Open Set:   \${searchState.openSet.size}\`, panelX + 5, panelY + 32);
    ctx.fillStyle = 'rgba(150, 150, 200, 1)';
    ctx.fillText(\`Closed Set: \${searchState.closedSet.size}\`, panelX + 5, panelY + 45);
    ctx.fillStyle = '#ffe66d';
    ctx.fillText(\`Nodes:      \${searchState.nodesSearched}\`, panelX + 5, panelY + 58);

    if (searchState.completed) {
        const time = (searchState.endTime - searchState.startTime).toFixed(2);
        ctx.fillStyle = searchState.found ? '#4ecdc4' : '#ff6b6b';
        ctx.fillText(searchState.found ? \`Path found! \${searchState.path.length} nodes\` : 'No path found!', panelX + 5, panelY + 73);
        ctx.fillStyle = '#888';
        ctx.fillText(\`Time: \${time}ms\`, panelX + 5, panelY + 86);
    } else if (searchState.running) {
        ctx.fillStyle = '#4ecdc4';
        ctx.fillText('Searching...', panelX + 5, panelY + 73);
    } else {
        ctx.fillStyle = '#888';
        ctx.fillText('Click to set start/end', panelX + 5, panelY + 73);
    }

    // å›¾ä¾‹
    const legendX = WIDTH - 120, legendY = 5;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(legendX, legendY, 115, 70);
    ctx.font = '9px monospace';

    ctx.fillStyle = 'rgba(0, 200, 255, 0.6)';
    ctx.fillRect(legendX + 5, legendY + 8, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Open (frontier)', legendX + 22, legendY + 18);

    ctx.fillStyle = 'rgba(100, 100, 150, 0.5)';
    ctx.fillRect(legendX + 5, legendY + 25, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Closed (explored)', legendX + 22, legendY + 35);

    ctx.fillStyle = '#ffe66d';
    ctx.fillRect(legendX + 5, legendY + 42, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Current path', legendX + 22, legendY + 52);

    ctx.fillStyle = '#4ecdc4';
    ctx.fillRect(legendX + 5, legendY + 59, 12, 12);
    ctx.fillStyle = '#fff';
    ctx.fillText('Final path', legendX + 22, legendY + 69);
}

// ============================================
// åœ°å›¾ç”Ÿæˆ
// ============================================

function generateMap(type) {
    gridWidth = params.gridSize;
    gridHeight = Math.floor(gridWidth * HEIGHT / WIDTH);

    gridMap = createGridMap(gridWidth, gridHeight);

    // é‡ç½®æœç´¢çŠ¶æ€
    searchState = {
        running: false,
        completed: false,
        found: false,
        openSet: new Map(),
        closedSet: new Set(),
        path: [],
        currentBest: null,
        nodesSearched: 0,
        startTime: 0,
        endTime: 0
    };

    const w = gridWidth, h = gridHeight;

    const generators = {
        simple: () => {
            // ç©ºåœ°å›¾ï¼Œç®€å•è·¯å¾„
            startPos = { x: 2, y: Math.floor(h / 2) };
            endPos = { x: w - 3, y: Math.floor(h / 2) };
        },
        obstacle: () => {
            // ä¸­é—´æœ‰éšœç¢ç‰©
            const midX = Math.floor(w / 2);
            for (let y = 3; y < h - 3; y++) {
                gridMap.setWalkable(midX, y, false);
            }
            startPos = { x: 3, y: Math.floor(h / 2) };
            endPos = { x: w - 4, y: Math.floor(h / 2) };
        },
        maze: () => {
            // ç®€å•è¿·å®«
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    gridMap.setWalkable(x, y, false);
                }
            }
            const carve = (x, y) => {
                gridMap.setWalkable(x, y, true);
                const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(() => Math.random() - 0.5);
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < w-1 && ny > 0 && ny < h-1 && !gridMap.isWalkable(nx, ny)) {
                        gridMap.setWalkable(x + dx/2, y + dy/2, true);
                        carve(nx, ny);
                    }
                }
            };
            carve(1, 1);
            startPos = { x: 1, y: 1 };
            endPos = findWalkable(w - 2, h - 2);
        },
        deadend: () => {
            // æ­»è·¯æµ‹è¯•ï¼ˆç»ˆç‚¹è¢«åŒ…å›´ï¼‰
            const cx = Math.floor(w / 2);
            const cy = Math.floor(h / 2);
            // å›´å¢™
            for (let x = cx - 3; x <= cx + 3; x++) {
                gridMap.setWalkable(x, cy - 3, false);
                gridMap.setWalkable(x, cy + 3, false);
            }
            for (let y = cy - 3; y <= cy + 3; y++) {
                gridMap.setWalkable(cx - 3, y, false);
                gridMap.setWalkable(cx + 3, y, false);
            }
            startPos = { x: 2, y: 2 };
            endPos = { x: cx, y: cy };
        }
    };

    generators[type]?.();
}

function findWalkable(px, py) {
    if (gridMap.isWalkable(px, py)) return { x: px, y: py };
    for (let r = 1; r < 20; r++) {
        for (let dx = -r; dx <= r; dx++) {
            for (let dy = -r; dy <= r; dy++) {
                const x = px + dx, y = py + dy;
                if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                    if (gridMap.isWalkable(x, y)) return { x, y };
                }
            }
        }
    }
    return { x: 1, y: 1 };
}

// ============================================
// åˆå§‹åŒ–
// ============================================

generateMap('simple');
initSearch();  // è‡ªåŠ¨å¼€å§‹æœç´¢

// ç‚¹å‡»è®¾ç½®èµ·ç‚¹/ç»ˆç‚¹å¹¶å¼€å§‹æœç´¢
let clickMode = 'start';
canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const cellW = WIDTH / gridWidth;
    const cellH = HEIGHT / gridHeight;
    const gx = Math.floor(mx / cellW);
    const gy = Math.floor(my / cellH);

    if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight && gridMap.isWalkable(gx, gy)) {
        if (clickMode === 'start') {
            startPos = { x: gx, y: gy };
            clickMode = 'end';
        } else {
            endPos = { x: gx, y: gy };
            clickMode = 'start';
            // å¼€å§‹æœç´¢
            initSearch();
        }
    }
});

// åœºæ™¯åˆ‡æ¢
window.__demoScene = {
    loadScenario: (type) => {
        generateMap(type);
        initSearch();
    }
};

// æ¸¸æˆå¾ªç¯
function gameLoop() {
    // æ¯å¸§æ‰§è¡Œå¤šæ­¥æœç´¢
    if (searchState.running) {
        for (let i = 0; i < params.speed; i++) {
            stepSearch();
        }
    }

    render(ctx);
    requestAnimationFrame(gameLoop);
}

gameLoop();`;

è¿™æ˜¯ä¸€ä¸ª **A* æœç´¢å¯è§†åŒ–æ¼”ç¤º**ï¼Œå¸®åŠ©ç†è§£å¯å‘å¼æœç´¢ç®—æ³•çš„å·¥ä½œåŸç†ã€‚

ç‚¹å‡» **Run** å¼€å§‹ï¼Œç„¶åç‚¹å‡»åœ°å›¾è®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹ã€‚

**é¢œè‰²è¯´æ˜ï¼š**
- ğŸŸ¦ **è“è‰²** - Open Setï¼ˆå¾…æ¢ç´¢çš„è¾¹ç•ŒèŠ‚ç‚¹ï¼‰
- ğŸŸ« **ç°ç´«è‰²** - Closed Setï¼ˆå·²æ¢ç´¢çš„èŠ‚ç‚¹ï¼‰
- ğŸŸ¨ **é»„è‰²çº¿** - å½“å‰æœ€ä½³è·¯å¾„
- ğŸŸ© **é’è‰²çº¿** - æœ€ç»ˆè·¯å¾„

<DemoPlayground
    client:load
    title="A* æœç´¢å¯è§†åŒ–"
    code={vizDemoCode}
    canvasWidth={580}
    canvasHeight={380}
    scenes={vizScenes}
    params={vizParams}
/>

<script is:inline src="/esengine/js/esengine.iife.js"></script>

## A* ç®—æ³•åŸç†

A* ç®—æ³•é€šè¿‡ç»´æŠ¤ä¸¤ä¸ªé›†åˆæ¥æœç´¢æœ€çŸ­è·¯å¾„ï¼š

| é›†åˆ | ä½œç”¨ |
|------|------|
| **Open Set** | å·²å‘ç°ä½†æœªæ¢ç´¢çš„èŠ‚ç‚¹ï¼ˆæœç´¢è¾¹ç•Œï¼‰ |
| **Closed Set** | å·²å®Œå…¨æ¢ç´¢çš„èŠ‚ç‚¹ |

æ¯æ¬¡è¿­ä»£é€‰æ‹© Open Set ä¸­ **f(n) = g(n) + h(n)** æœ€å°çš„èŠ‚ç‚¹å±•å¼€ï¼š
- **g(n)** - ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å®é™…ä»£ä»·
- **h(n)** - ä»å½“å‰èŠ‚ç‚¹åˆ°ç»ˆç‚¹çš„å¯å‘å¼ä¼°è®¡

## åœºæ™¯è¯´æ˜

- **ç®€å•è·¯å¾„** - æ— éšœç¢ç›´çº¿ï¼Œè§‚å¯Ÿç®—æ³•å¦‚ä½•"ç›´å¥”"ç›®æ ‡
- **ç»•è¿‡éšœç¢** - çœ‹ç®—æ³•å¦‚ä½•åœ¨é‡åˆ°éšœç¢æ—¶è°ƒæ•´æ–¹å‘
- **è¿·å®«** - å¤æ‚ç¯å¢ƒä¸‹çš„æœç´¢è¡Œä¸º
- **æ­»è·¯æµ‹è¯•** - ç»ˆç‚¹è¢«åŒ…å›´ï¼Œè§‚å¯Ÿç®—æ³•æ¢ç´¢æ•´ä¸ªå¯è¾¾åŒºåŸŸ

## ç›¸å…³æ–‡æ¡£

- [ç®—æ³•å¯¹æ¯”æ¼”ç¤º](/esengine/examples/algorithm-comparison-demo) - æ¯”è¾ƒä¸åŒç®—æ³•
- [å¯»è·¯ç³»ç»Ÿ API](/esengine/modules/pathfinding) - å®Œæ•´æ–‡æ¡£
