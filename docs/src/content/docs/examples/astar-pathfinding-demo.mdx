---
title: "A* 寻路演示"
description: "使用 ECS 架构实现的 A* 网格寻路交互式演示"
---

import DemoPlayground from '../../../components/DemoPlayground.vue';

export const astarScenes = [
    { id: 'maze', label: '⬛', name: '迷宫' },
    { id: 'random', label: '✦', name: '随机障碍' },
    { id: 'rooms', label: '⬜', name: '房间' },
    { id: 'spiral', label: '◎', name: '螺旋' }
];

export const astarParams = [
    { id: 'gridSize', label: 'Grid', desc: '网格大小（越大越精细）', value: 40, min: 20, max: 80, step: 10 },
    { id: 'obstacleRate', label: 'Obstacles', desc: '障碍物密度（%）', value: 25, min: 10, max: 50, step: 5 },
    { id: 'diagonal', label: 'Diagonal', desc: '是否允许对角移动（0=否，1=是）', value: 1, min: 0, max: 1, step: 1 },
    { id: 'speed', label: 'Speed', desc: '代理移动速度（网格/秒）', value: 5, min: 1, max: 15, step: 1 }
];

export const astarDemoCode = `// A* 寻路 - ECS 架构演示
// ============================================
// 点击地图设置起点和终点，观察 A* 寻路过程

const {
    Core, Scene, Component, EntitySystem, Matcher, Time,
    ECSComponent, ECSSystem,
    PathfindingAgentComponent, PathfindingMapComponent, PathfindingSystem
} = ESEngine;

const WIDTH = 580, HEIGHT = 380;

const params = window.__demoParams || {
    gridSize: 40, obstacleRate: 25, diagonal: 1, speed: 5
};

// ============================================
// 组件定义
// ============================================

@ECSComponent('Visual')
class VisualComponent extends Component {
    color = '#00d4ff';
    showPath = true;
}

// ============================================
// 渲染系统
// ============================================

@ECSSystem('Render', { updateOrder: 100 })
class RenderSystem extends EntitySystem {
    ctx: CanvasRenderingContext2D;
    mapComp: PathfindingMapComponent | null = null;
    fps = 0; frameCount = 0; lastFpsTime = 0;

    constructor(context: CanvasRenderingContext2D) {
        super(Matcher.all(PathfindingAgentComponent, VisualComponent));
        this.ctx = context;
    }

    process(entities) {
        const ctx = this.ctx;

        // 清屏
        ctx.fillStyle = '#16213e';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // 查找地图组件
        if (!this.mapComp) {
            const mapEntities = this.scene.entities.findEntitiesWithComponent(PathfindingMapComponent);
            if (mapEntities.length > 0) {
                this.mapComp = mapEntities[0].getComponent(PathfindingMapComponent);
            }
        }

        // 绘制网格
        if (this.mapComp?.map) {
            const map = this.mapComp.map;
            const cellW = WIDTH / map.width;
            const cellH = HEIGHT / map.height;

            // 绘制障碍物
            ctx.fillStyle = '#2d4263';
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    if (!map.isWalkable(x, y)) {
                        ctx.fillRect(x * cellW, y * cellH, cellW - 1, cellH - 1);
                    }
                }
            }

            // 绘制网格线
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= map.width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cellW, 0);
                ctx.lineTo(x * cellW, HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= map.height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cellH);
                ctx.lineTo(WIDTH, y * cellH);
                ctx.stroke();
            }
        }

        // FPS 计算
        this.frameCount++;
        const now = performance.now();
        if (now - this.lastFpsTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastFpsTime = now;
        }

        // 绘制代理和路径
        for (const entity of entities) {
            const agent = entity.getComponent(PathfindingAgentComponent);
            const visual = entity.getComponent(VisualComponent);

            if (!this.mapComp?.map) continue;
            const cellW = WIDTH / this.mapComp.map.width;
            const cellH = HEIGHT / this.mapComp.map.height;

            // 绘制路径
            if (visual.showPath && agent.path.length > 0) {
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.4)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(agent.x * cellW + cellW/2, agent.y * cellH + cellH/2);
                for (const p of agent.path) {
                    ctx.lineTo(p.x * cellW + cellW/2, p.y * cellH + cellH/2);
                }
                ctx.stroke();

                // 绘制路径点
                ctx.fillStyle = 'rgba(0, 212, 255, 0.6)';
                for (let i = agent.pathIndex; i < agent.path.length; i++) {
                    const p = agent.path[i];
                    ctx.beginPath();
                    ctx.arc(p.x * cellW + cellW/2, p.y * cellH + cellH/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 绘制目标点
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(agent.targetX * cellW + cellW/2, agent.targetY * cellH + cellH/2, 6, 0, Math.PI * 2);
            ctx.fill();

            // 绘制代理
            const x = agent.x * cellW + cellW/2;
            const y = agent.y * cellH + cellH/2;

            // 光晕
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
            gradient.addColorStop(0, visual.color);
            gradient.addColorStop(1, 'transparent');
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // 代理圆
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fillStyle = visual.color;
            ctx.fill();
        }

        // HUD
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(5, 5, 140, 50);
        ctx.fillStyle = '#00d4ff';
        ctx.font = '11px monospace';
        ctx.fillText(\`Grid: \${this.mapComp?.width || 0}x\${this.mapComp?.height || 0}\`, 10, 20);
        ctx.fillText(\`FPS: \${this.fps}\`, 10, 32);
        const agent = entities[0]?.getComponent(PathfindingAgentComponent);
        ctx.fillText(\`Path: \${agent?.path.length || 0} nodes\`, 10, 44);
    }
}

// ============================================
// 移动系统
// ============================================

@ECSSystem('Movement', { updateOrder: 50 })
class MovementSystem extends EntitySystem {
    mapComp: PathfindingMapComponent | null = null;

    constructor() {
        super(Matcher.all(PathfindingAgentComponent));
    }

    process(entities) {
        if (!this.mapComp) {
            const mapEntities = this.scene.entities.findEntitiesWithComponent(PathfindingMapComponent);
            if (mapEntities.length > 0) {
                this.mapComp = mapEntities[0].getComponent(PathfindingMapComponent);
            }
        }
        if (!this.mapComp?.map) return;

        const cellW = WIDTH / this.mapComp.map.width;
        const cellH = HEIGHT / this.mapComp.map.height;
        const dt = Time.deltaTime;
        const moveSpeed = params.speed * dt;

        for (const entity of entities) {
            const agent = entity.getComponent(PathfindingAgentComponent);

            if (!agent.hasValidPath() || agent.isPathComplete()) continue;

            const waypoint = agent.getNextWaypoint();
            if (!waypoint) continue;

            const dx = waypoint.x - agent.x;
            const dy = waypoint.y - agent.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 0.1) {
                agent.x = waypoint.x;
                agent.y = waypoint.y;
                agent.advanceWaypoint();
            } else {
                const moveRatio = Math.min(moveSpeed / dist, 1);
                agent.x += dx * moveRatio;
                agent.y += dy * moveRatio;
            }
        }
    }
}

// ============================================
// 场景
// ============================================

class AStarDemoScene extends Scene {
    mapEntity: any;
    agentEntity: any;

    initialize() {
        this.name = 'AStarDemo';
        this.addSystem(new PathfindingSystem());
        this.addSystem(new MovementSystem());
        this.addSystem(new RenderSystem(ctx));
    }

    onStart() {
        this.loadScenario('maze');
    }

    loadScenario(type: string) {
        console.log('loadScenario called:', type);

        // 清除现有实体（使用正确的API）
        if (this.mapEntity) {
            this.mapEntity.destroy();
            this.mapEntity = null;
        }
        if (this.agentEntity) {
            this.agentEntity.destroy();
            this.agentEntity = null;
        }

        // 重置渲染系统的地图引用
        for (const system of this.systems) {
            if (system.mapComp) system.mapComp = null;
        }

        const gridSize = params.gridSize;

        // 创建地图实体
        this.mapEntity = this.createEntity('Map');
        const mapComp = this.mapEntity.addComponent(new PathfindingMapComponent());
        mapComp.width = gridSize;
        mapComp.height = Math.floor(gridSize * HEIGHT / WIDTH);
        mapComp.allowDiagonal = params.diagonal === 1;
        mapComp.avoidCorners = true;
        mapComp.enableSmoothing = false;

        // 创建代理
        this.agentEntity = this.createEntity('Agent');
        const agent = this.agentEntity.addComponent(new PathfindingAgentComponent());
        const visual = this.agentEntity.addComponent(new VisualComponent());
        visual.color = '#00d4ff';

        // 等待地图初始化后生成障碍物
        setTimeout(() => {
            if (!mapComp.map) return;

            const generators = {
                maze: () => this.generateMaze(mapComp),
                random: () => this.generateRandom(mapComp),
                rooms: () => this.generateRooms(mapComp),
                spiral: () => this.generateSpiral(mapComp)
            };
            generators[type]?.();

            // 找到起点和终点（spiral 场景特殊处理：从中心到边缘）
            let start, end;
            if (type === 'spiral') {
                const cx = Math.floor(mapComp.width / 2);
                const cy = Math.floor(mapComp.height / 2);
                start = { x: cx, y: cy };  // 中心
                end = this.findWalkable(mapComp, 1, 1);  // 边缘
            } else {
                start = this.findWalkable(mapComp, 1, 1);
                end = this.findWalkable(mapComp, mapComp.width - 2, mapComp.height - 2);
            }

            agent.x = start.x;
            agent.y = start.y;
            agent.requestPathTo(end.x, end.y);
        }, 100);
    }

    findWalkable(mapComp, preferX, preferY) {
        if (mapComp.isWalkable(preferX, preferY)) return { x: preferX, y: preferY };
        for (let r = 1; r < 10; r++) {
            for (let dx = -r; dx <= r; dx++) {
                for (let dy = -r; dy <= r; dy++) {
                    const x = preferX + dx, y = preferY + dy;
                    if (x >= 0 && x < mapComp.width && y >= 0 && y < mapComp.height) {
                        if (mapComp.isWalkable(x, y)) return { x, y };
                    }
                }
            }
        }
        return { x: 1, y: 1 };
    }

    generateMaze(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        // 填充所有为墙
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                mapComp.setWalkable(x, y, false);
            }
        }
        // 递归分割生成迷宫
        const carve = (x, y) => {
            mapComp.setWalkable(x, y, true);
            const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(() => Math.random() - 0.5);
            for (const [dx, dy] of dirs) {
                const nx = x + dx, ny = y + dy;
                if (nx > 0 && nx < w-1 && ny > 0 && ny < h-1 && !mapComp.isWalkable(nx, ny)) {
                    mapComp.setWalkable(x + dx/2, y + dy/2, true);
                    carve(nx, ny);
                }
            }
        };
        carve(1, 1);
    }

    generateRandom(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        const rate = params.obstacleRate / 100;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (x === 1 && y === 1) continue;
                if (x === w-2 && y === h-2) continue;
                mapComp.setWalkable(x, y, Math.random() > rate);
            }
        }
    }

    generateRooms(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        // 全部可通行
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                mapComp.setWalkable(x, y, true);
            }
        }
        // 生成房间墙壁
        const roomW = Math.floor(w / 4);
        const roomH = Math.floor(h / 3);
        for (let ry = 0; ry < 3; ry++) {
            for (let rx = 0; rx < 4; rx++) {
                const bx = rx * roomW, by = ry * roomH;
                // 画墙
                for (let x = bx; x < bx + roomW && x < w; x++) {
                    if (by < h) mapComp.setWalkable(x, by, false);
                    if (by + roomH - 1 < h) mapComp.setWalkable(x, by + roomH - 1, false);
                }
                for (let y = by; y < by + roomH && y < h; y++) {
                    if (bx < w) mapComp.setWalkable(bx, y, false);
                    if (bx + roomW - 1 < w) mapComp.setWalkable(bx + roomW - 1, y, false);
                }
                // 开门
                const doorX = bx + Math.floor(roomW / 2);
                const doorY = by + Math.floor(roomH / 2);
                if (doorX < w && by < h) mapComp.setWalkable(doorX, by, true);
                if (doorX < w && by + roomH - 1 < h) mapComp.setWalkable(doorX, by + roomH - 1, true);
                if (bx < w && doorY < h) mapComp.setWalkable(bx, doorY, true);
                if (bx + roomW - 1 < w && doorY < h) mapComp.setWalkable(bx + roomW - 1, doorY, true);
            }
        }
    }

    generateSpiral(mapComp) {
        const w = mapComp.width, h = mapComp.height;
        const cx = Math.floor(w / 2), cy = Math.floor(h / 2);
        const maxDist = Math.min(cx, cy) - 1;

        // 先全部设为可行走
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                mapComp.setWalkable(x, y, true);
            }
        }

        // 生成螺旋墙壁，但保留通道
        for (let ring = 3; ring < maxDist; ring += 3) {
            // 画圆环墙壁，但留一个开口
            const openingAngle = (ring * 0.5) % (Math.PI * 2);
            for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                // 每圈留一个 60 度的开口
                const angleDiff = Math.abs(((angle - openingAngle + Math.PI) % (Math.PI * 2)) - Math.PI);
                if (angleDiff > 0.5) {
                    const x = Math.round(cx + Math.cos(angle) * ring);
                    const y = Math.round(cy + Math.sin(angle) * ring);
                    if (x >= 0 && x < w && y >= 0 && y < h) {
                        mapComp.setWalkable(x, y, false);
                    }
                }
            }
        }
    }
}

// ============================================
// 初始化
// ============================================

Core.create({ debug: false });
const demoScene = new AStarDemoScene();
Core.setScene(demoScene);

// 暴露场景给 DemoPlayground 以支持场景切换
window.__demoScene = demoScene;

let lastTime = performance.now();

function gameLoop() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    Core.update(dt);
    requestAnimationFrame(gameLoop);
}

gameLoop();`;

这是一个使用 **ECS 架构** 实现的 A* 网格寻路交互式演示。

点击 **Run** 启动模拟，使用工具栏切换不同的地图场景，调整参数观察寻路效果。

<DemoPlayground
    client:load
    title="A* 寻路 - ECS 架构"
    code={astarDemoCode}
    canvasWidth={580}
    canvasHeight={380}
    scenes={astarScenes}
    params={astarParams}
/>

<script is:inline src="/esengine/js/esengine.iife.js"></script>

## 场景说明

- **迷宫** - 使用递归分割算法生成的迷宫，测试长路径寻路
- **随机障碍** - 随机分布的障碍物，可调整密度
- **房间** - 模拟房间布局，测试门和走廊
- **螺旋** - 螺旋形障碍物，测试复杂路径

## 相关文档

- [寻路系统 API](/esengine/modules/pathfinding) - 完整 API 文档和使用指南
- [ORCA 局部避让](/esengine/modules/pathfinding/local-avoidance) - 多代理避让
- [快速开始](/esengine/guide/getting-started) - ECS 框架入门
